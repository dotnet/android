<!--
***********************************************************************************************
Microsoft.Android.Sdk.NativeAOT.targets

This file contains the NativeAOT-specific MSBuild logic for .NET for Android.
***********************************************************************************************
-->
<Project>

  <UsingTask TaskName="Xamarin.Android.Tasks.SetNdkPathForIlc" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateNativeAotLibraryLoadAssemblerSources" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateNativeAotEnvironmentAssemblerSources" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateProguardFromTypeMap" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.AppendMarshalMethodExports" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />

  <!-- Default property values for NativeAOT -->
  <PropertyGroup>
    <_AndroidRuntimePackRuntime>NativeAOT</_AndroidRuntimePackRuntime>
    <_AndroidJcwCodegenTarget Condition=" '$(_AndroidJcwCodegenTarget)' == '' ">JavaInterop1</_AndroidJcwCodegenTarget>
    <!-- .NET SDK gives: error NETSDK1191: A runtime identifier for the property 'PublishAot' couldn't be inferred. Specify a rid explicitly. -->
    <AllowPublishAotWithoutRuntimeIdentifier Condition=" '$(AllowPublishAotWithoutRuntimeIdentifier)' == '' ">true</AllowPublishAotWithoutRuntimeIdentifier>
    <!-- NativeAOT's targets currently gives an error about cross-compilation -->
    <DisableUnsupportedError Condition=" $([MSBuild]::IsOSPlatform('windows')) and '$(DisableUnsupportedError)' == '' ">true</DisableUnsupportedError>
    <!-- HACK: make dotnet restore include Microsoft.NETCore.App.Runtime.NativeAOT.linux-bionic-arm64 -->
    <_IsPublishing Condition=" '$(_IsPublishing)' == '' ">true</_IsPublishing>
  </PropertyGroup>

  <!-- Default property values for NativeAOT Debug configuration -->
  <PropertyGroup Condition="'$(DebugSymbols)' == 'true'">
    <NativeDebugSymbols>true</NativeDebugSymbols>
    <StripSymbols>false</StripSymbols>
    <CompressSymbols>false</CompressSymbols>
  </PropertyGroup>

  <!-- Default feature switches -->
  <ItemGroup>
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsMonoRuntime"
        Value="false"
        Trim="true"
    />
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsCoreClrRuntime"
        Value="false"
        Trim="true"
    />
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsNativeAotRuntime"
        Value="true"
        Trim="true"
    />
  </ItemGroup>

  <!-- Make IlcCompile depend on assembly resolution - NO ILLink, ILC does its own trimming -->
  <PropertyGroup>
    <IlcCompileDependsOn>
      _AndroidBeforeIlcCompile;
      SetupOSSpecificProps;
      ComputeIlcCompileInputs;
      _AndroidComputeIlcCompileInputs;
      $(IlcCompileDependsOn)
    </IlcCompileDependsOn>
  </PropertyGroup>

  <Target Name="_AndroidBeforeIlcCompile"
      DependsOnTargets="_GenerateTypeMapAssembly"
      BeforeTargets="SetupProperties">
    <!-- Example settings from: https://github.com/jonathanpeppers/Android-NativeAOT/blob/ea69d122cdc7de67aa6a5db14b7e560763c63cdd/DotNet/libdotnet.targets -->
    <PropertyGroup>
      <_NdkAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' ">aarch64</_NdkAbi>
      <_NdkAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' ">x86_64</_NdkAbi>
      <_NdkSysrootAbi>$(_NdkAbi)-linux-android</_NdkSysrootAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('windows')) ">windows-x86_64</_NdkPrebuiltAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('osx')) ">darwin-x86_64</_NdkPrebuiltAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('linux')) ">linux-x86_64</_NdkPrebuiltAbi>
      <_NdkSysrootDir>$(_AndroidNdkDirectory)toolchains/llvm/prebuilt/$(_NdkPrebuiltAbi)/sysroot/usr/lib/$(_NdkSysrootAbi)/</_NdkSysrootDir>
      <_NdkBinDir>$(_AndroidNdkDirectory)toolchains/llvm/prebuilt/$(_NdkPrebuiltAbi)/bin/</_NdkBinDir>
      <CppCompilerAndLinker>clang++</CppCompilerAndLinker>
      <ObjCopyName>llvm-objcopy</ObjCopyName>

      <!-- We must ensure this is `false`, as it would interfere with statically linking libc++ -->
      <LinkStandardCPlusPlusLibrary>false</LinkStandardCPlusPlusLibrary>

      <!-- DISABLE ILLink - NativeAOT ILC does its own whole-program trimming -->
      <RunILLink>false</RunILLink>
      <_RequiresILLink>false</_RequiresILLink>

      <!-- For TypeMap V3: Do NOT include legacy JAR files. All Java code is generated by GenerateTypeMapAssembly. -->
      <_RuntimeJar Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></_RuntimeJar>
      <MonoPlatformJarPath Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></MonoPlatformJarPath>

      <!-- For TypeMap V3 PoC: Disable R8/ProGuard - we don't have a way to determine which types survived ILC trimming yet -->
      <AndroidLinkTool Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></AndroidLinkTool>
      
      <!-- For TypeMap V3: Tell ILC which assembly contains TypeMapAttribute entries -->
      <TypeMapEntryAssembly Condition=" '$(AndroidEnableTypeMaps)' == 'true' ">$(_TypeMapEntryAssemblyName)</TypeMapEntryAssembly>
    </PropertyGroup>

    <SetNdkPathForIlc NdkBinDirectory="$(_NdkBinDir)" />
  </Target>

  <Target Name="_AndroidComputeIlcCompileInputs"
      DependsOnTargets="_GenerateTypeMapAssembly">
    <ItemGroup>
      <!-- Android needs a proper soname property or it will refuse to load the library -->
      <LinkerArg Include="&quot;-Wl,-soname,lib$(TargetName)$(NativeBinaryExt)&quot;" />
      <LinkerArg Include="-Wl,--error-unresolved-symbols" />
      <LinkerArg Include="-Wl,--no-undefined" />

      <!-- Required for [UnmanagedCallersOnly] to work inside this assembly -->
      <UnmanagedEntryPointsAssembly Include="Microsoft.Android.Runtime.NativeAOT" />
      
      <!-- Give UNTRIMMED assemblies directly to ILC - ILC does its own trimming -->
      <!-- Use _OuterIntermediateOutputPath for the app assembly (from outer non-RID build) -->
      <IlcCompileInput Remove="@(IlcCompileInput)" />
      <IlcCompileInput Include="$(_OuterIntermediateOutputPath)$(TargetName)$(TargetExt)" />
      
      <!-- Add TypeMaps assembly as a ROOT assembly (IlcCompileInput), not just a reference.
           This ensures ILC includes it even if nothing directly references it.
           The assembly is needed at runtime for type mapping. -->
      <IlcCompileInput Include="@(_TypeMapGeneratedAssembly)" Condition=" '$(AndroidEnableTypeMaps)' == 'true' " />
      
      <!-- Satellite assemblies -->
      <IlcSatelliteAssembly Include="$(_OuterIntermediateSatelliteAssembliesWithTargetPath)" />

      <_NdkLibs Include="@(RuntimePackAsset->WithMetadataValue('Filename', 'libnaot-android.$(Configuration.ToLower())-static-$(Configuration.ToLower())'))" />

      <!-- Include libc++ -->
      <_NdkLibs Include="$(_NdkSysrootDir)libc++_static.a" />
      <_NdkLibs Include="$(_NdkSysrootDir)libc++abi.a" />

      <LinkerArg Include="&quot;%(_NdkLibs.Identity)&quot;" />

      <!-- This library conflicts with static libc++ -->
      <NativeLibrary Remove="$(IlcSdkPath)libstdc++compat.a" />
      <LinkerArg Remove="$(IlcSdkPath)libstdc++compat.a" />

      <!-- Every p/invoke using the `xa-internal-api` "library" will be called directly -->
      <DirectPInvoke Include="xa-internal-api" />
    </ItemGroup>
  </Target>

  <Target Name="_PrepareNativeAotAndroidAppInputs">
    <ItemGroup>
      <_PrivateBuildTargetAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' " Include="arm64-v8a" />
      <_PrivateBuildTargetAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' " Include="x86_64" />
    </ItemGroup>

    <PrepareAbiItems
        BuildTargetAbis="@(_PrivateBuildTargetAbi)"
        NativeSourcesDir="$(_NativeAssemblySourceDir)"
        Debug="$(AndroidIncludeDebugSymbols)"
        Mode="jni_init">
      <Output TaskParameter="AssemblySources" ItemName="_PrivateJniInitFuncsAssemblySource" />
    </PrepareAbiItems>

    <PrepareAbiItems
        BuildTargetAbis="@(_PrivateBuildTargetAbi)"
        NativeSourcesDir="$(_NativeAssemblySourceDir)"
        Debug="$(AndroidIncludeDebugSymbols)"
        Mode="environment">
      <Output TaskParameter="AssemblySources" ItemName="_PrivateEnvironmentAssemblySource" />
    </PrepareAbiItems>

    <ItemGroup>
      <_PrivateJniInitFuncsNativeObjectFile Include="@(_PrivateJniInitFuncsAssemblySource->'$([System.IO.Path]::ChangeExtension('%(Identity)', '.o'))')">
        <abi>%(_PrivateJniInitFuncsAssemblySource.abi)</abi>
      </_PrivateJniInitFuncsNativeObjectFile>

      <_PrivateEnvironmentNativeObjectFile Include="@(_PrivateEnvironmentAssemblySource->'$([System.IO.Path]::ChangeExtension('%(Identity)', '.o'))')">
        <abi>%(_PrivateEnvironmentAssemblySource.abi)</abi>
      </_PrivateEnvironmentNativeObjectFile>

      <_PrivateAndroidNaotResolvedAssemblyFiles Include="@(ResolvedFileToPublish->Distinct())" Condition=" '%(ResolvedFileToPublish.Extension)' == '.dll' " />
    </ItemGroup>
  </Target>

  <Target
      Name="_GenerateNativeAotAndroidAppAssemblerSources"
      DependsOnTargets="_ResolveSdks;_GenerateEnvironmentFiles;_PrepareNativeAotAndroidAppInputs"
      Inputs="@(_PrivateAndroidNaotResolvedAssemblyFiles);@(AndroidEnvironment);@(LibraryEnvironments)"
      Outputs="@(_PrivateJniInitFuncsAssemblySource);@(_PrivateJniInitFuncsNativeObjectFile);@(_PrivateEnvironmentAssemblySource);@(_PrivateEnvironmentNativeObjectFile)">
    <GenerateNativeAotLibraryLoadAssemblerSources
        ResolvedAssemblies="@(_PrivateAndroidNaotResolvedAssemblyFiles)"
        CustomJniInitFunctions="@(AndroidStaticJniInitFunction)"
        OutputSources="@(_PrivateJniInitFuncsAssemblySource)" />

    <GenerateNativeAotEnvironmentAssemblerSources
        Environments="@(AndroidEnvironment);@(LibraryEnvironments)"
        HttpClientHandlerType="$(AndroidHttpClientHandlerType)"
        OutputSources="@(_PrivateEnvironmentAssemblySource)"
        RID="$(RuntimeIdentifier)" />

    <CompileNativeAssembly
        Sources="@(_PrivateJniInitFuncsAssemblySource);@(_PrivateEnvironmentAssemblySource)"
        DebugBuild="$(AndroidIncludeDebugSymbols)"
        WorkingDirectory="$(_NativeAssemblySourceDir)"
        AndroidBinUtilsDirectory="$(AndroidBinUtilsDirectory)" />

    <ItemGroup>
      <LinkerArg Include="@(_PrivateJniInitFuncsNativeObjectFile)" />
      <LinkerArg Include="@(_PrivateEnvironmentNativeObjectFile)" />
    </ItemGroup>
  </Target>

  <!-- Compile and link TypeMap V3 marshal methods for NativeAOT.
       These LLVM IR files define JNI native method stubs that need to be exported. -->
  <Target
      Name="_CompileTypeMapMarshalMethodsForNativeAot"
      BeforeTargets="LinkNative"
      DependsOnTargets="_ResolveSdks;_GenerateTypeMapAssembly"
      Condition=" '$(AndroidEnableTypeMaps)' == 'true' ">
    <PropertyGroup>
      <_AndroidMarshalMethodsDir>$(IntermediateOutputPath)android</_AndroidMarshalMethodsDir>
    </PropertyGroup>

    <!-- Collect the marshal method LLVM IR files -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSourceRaw Include="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_*.ll" />
    </ItemGroup>

    <!-- Set ABI metadata for compilation (NativeAOT currently only supports arm64) -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSource Include="@(_TypeMapMarshalMethodsSourceRaw)">
        <abi>arm64-v8a</abi>
      </_TypeMapMarshalMethodsSource>
    </ItemGroup>

    <!-- Compile .ll files to .o files -->
    <CompileNativeAssembly
        Sources="@(_TypeMapMarshalMethodsSource)"
        DebugBuild="$(AndroidIncludeDebugSymbols)"
        WorkingDirectory="$(_AndroidMarshalMethodsDir)"
        AndroidBinUtilsDirectory="$(AndroidBinUtilsDirectory)"
        Condition=" '@(_TypeMapMarshalMethodsSource)' != '' " />

    <Message Importance="High" Text="[TypeMap] Looking for marshal methods in: $(_AndroidMarshalMethodsDir)" />
    <Message Importance="High" Text="[TypeMap] Raw source files: @(_TypeMapMarshalMethodsSourceRaw)" />
    <Message Importance="High" Text="[TypeMap] Source files with abi: @(_TypeMapMarshalMethodsSource)" />

    <!-- Define the object files -->
    <ItemGroup>
      <_TypeMapMarshalMethodsObjectFile Include="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_*.o">
        <abi>arm64-v8a</abi>
      </_TypeMapMarshalMethodsObjectFile>
    </ItemGroup>

    <Message Importance="High" Text="[TypeMap] Object files: @(_TypeMapMarshalMethodsObjectFile)" />

    <!-- Add to LinkerArg -->
    <ItemGroup>
      <LinkerArg Include="@(_TypeMapMarshalMethodsObjectFile)" />
    </ItemGroup>

    <Message Importance="High" Text="[TypeMap] Added object files to LinkerArg: @(_TypeMapMarshalMethodsObjectFile)" />

    <!-- Append marshal method symbols to ILC exports file -->
    <PropertyGroup>
      <_TypeMapMarshalMethodsExportsFile>$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_exports.txt</_TypeMapMarshalMethodsExportsFile>
    </PropertyGroup>
    <AppendMarshalMethodExports
        Condition=" Exists('$(_TypeMapMarshalMethodsExportsFile)') and Exists('$(ExportsFile)') "
        MarshalMethodsExportsFile="$(_TypeMapMarshalMethodsExportsFile)"
        ExportsFile="$(ExportsFile)" />
    <Message Importance="High"
             Condition=" Exists('$(_TypeMapMarshalMethodsExportsFile)') "
             Text="[TypeMap] Appended marshal method exports from $(_TypeMapMarshalMethodsExportsFile)" />
  </Target>

  <!-- Make sure we have a chance to generate our application-specific static library before linking
       takes place. We must run after `IlcCompile`, which is a dependency of `LinkNative`  -->
  <Target
      Name="_GenerateNativeAotAndroidAppLibrary"
      AfterTargets="IlcCompile"
      DependsOnTargets="_GenerateNativeAotAndroidAppAssemblerSources">
  </Target>

  <Target Name="_AndroidFixNativeLibraryFileName" AfterTargets="ComputeFilesToPublish">
    <ItemGroup>
      <!-- Fix paths to contain lib-prefix -->
      <ResolvedFileToPublish Update="@(ResolvedFileToPublish)" ArchiveFileName="lib%(FileName)%(Extension)" Condition=" '%(Filename)%(Extension)' == '$(TargetName)$(NativeBinaryExt)' " />
    </ItemGroup>
  </Target>

  <!-- Generate proguard keep rules for NativeAOT builds.
       Unlike ILLink-based builds, we generate keep rules directly from the TypeMaps assembly
       without waiting for ILLink to run (ILC does its own trimming). -->
  <Target Name="_GenerateProguardFromTypeMapForNativeAot"
      AfterTargets="_GenerateTypeMapAssembly"
      BeforeTargets="_CalculateProguardConfigurationFiles"
      Condition=" '$(AndroidEnableTypeMaps)' == 'true' and '$(AndroidLinkTool)' != '' ">
    <PropertyGroup>
      <!-- TypeMaps assembly is generated by _GenerateTypeMapAssembly in _TypeMapBaseOutputDir -->
      <!-- Match the path from Microsoft.Android.Sdk.ILLink.targets -->
      <_TypeMapBaseOutputDir>$(BaseIntermediateOutputPath)$(Configuration)$([System.IO.Path]::DirectorySeparatorChar)$(TargetFramework)$([System.IO.Path]::DirectorySeparatorChar)</_TypeMapBaseOutputDir>
      <_TypeMapAssemblyFileName>_Microsoft.Android.TypeMaps.dll</_TypeMapAssemblyFileName>
      <_TypeMapAssemblyPath>$(_TypeMapBaseOutputDir)typemap$([System.IO.Path]::DirectorySeparatorChar)$(_TypeMapAssemblyFileName)</_TypeMapAssemblyPath>
      <_TypeMapProguardConfig>$(IntermediateOutputPath)proguard$([System.IO.Path]::DirectorySeparatorChar)proguard_typemap.cfg</_TypeMapProguardConfig>
    </PropertyGroup>
    <MakeDir Directories="$(IntermediateOutputPath)proguard" />
    <GenerateProguardFromTypeMap
        Condition=" Exists('$(_TypeMapAssemblyPath)') "
        TypeMapsAssembly="$(_TypeMapAssemblyPath)"
        OutputProguardConfiguration="$(_TypeMapProguardConfig)"
        Enabled="true" />
    <!-- Add to proguard configuration files -->
    <ItemGroup Condition=" Exists('$(_TypeMapProguardConfig)') ">
      <ProguardConfiguration Include="$(_TypeMapProguardConfig)" />
    </ItemGroup>
    <Warning Condition=" !Exists('$(_TypeMapAssemblyPath)') "
             Text="TypeMaps assembly not found for proguard generation: $(_TypeMapAssemblyPath)" />
  </Target>

  <!-- Remove legacy Java.Interop JAR files for TypeMap V3 builds.
       TypeMap V3 generates ALL Java code - no legacy JAR files are needed.
       These JAR files contain classes like ManagedPeer, JavaProxyThrowable, etc.
       that have static initializers calling registerNativeMembers() which is not
       supported in TypeMap V3. -->
  <Target Name="_RemoveLegacyJavaInteropJarsForNativeAot"
      AfterTargets="_ResolveAssemblies;_GetLibraryImports"
      BeforeTargets="_DetermineJavaLibrariesToCompile"
      Condition=" '$(AndroidEnableTypeMaps)' == 'true' ">
    <Message Importance="high" Text="TypeMap V3: Removing legacy Java.Interop JAR files from build." />
    <Message Importance="high" Text="TypeMap V3: Before - AndroidJavaLibrary: @(AndroidJavaLibrary)" />
    <Message Importance="high" Text="TypeMap V3: Before - ExtractedJarImports: @(ExtractedJarImports)" />
    <ItemGroup>
      <!-- Remove java-interop.jar which contains ManagedPeer, JavaProxyThrowable, JavaProxyObject
           Note: We KEEP java_runtime_xxx.jar as they contain essential classes like IGCUserPeer, MonoPackageManager -->
      <AndroidJavaLibrary Remove="@(AndroidJavaLibrary)" Condition=" $([System.String]::new('%(Filename)').EndsWith('java-interop')) " />
      <!-- Remove from ExtractedJarImports as well -->
      <ExtractedJarImports Remove="@(ExtractedJarImports)" Condition=" $([System.String]::new('%(Filename)').EndsWith('java-interop')) " />
    </ItemGroup>
    <Message Importance="high" Text="TypeMap V3: After - AndroidJavaLibrary: @(AndroidJavaLibrary)" />
    <Message Importance="high" Text="TypeMap V3: After - ExtractedJarImports: @(ExtractedJarImports)" />
  </Target>

</Project>
