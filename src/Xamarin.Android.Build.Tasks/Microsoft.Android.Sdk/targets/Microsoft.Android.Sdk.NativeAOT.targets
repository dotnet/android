<!--
***********************************************************************************************
Microsoft.Android.Sdk.NativeAOT.targets

This file contains the NativeAOT-specific MSBuild logic for .NET for Android.
***********************************************************************************************
-->
<Project>

  <UsingTask TaskName="Xamarin.Android.Tasks.SetNdkPathForIlc" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateNativeAotLibraryLoadAssemblerSources" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateNativeAotEnvironmentAssemblerSources" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateProguardFromTypeMap" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.AppendMarshalMethodExports" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />
  <UsingTask TaskName="Xamarin.Android.Tasks.FilterMarshalMethodsByIlcMetadata" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />

  <!-- Default property values for NativeAOT -->
  <PropertyGroup>
    <_AndroidRuntimePackRuntime>NativeAOT</_AndroidRuntimePackRuntime>
    <_AndroidJcwCodegenTarget Condition=" '$(_AndroidJcwCodegenTarget)' == '' ">JavaInterop1</_AndroidJcwCodegenTarget>
    <!-- .NET SDK gives: error NETSDK1191: A runtime identifier for the property 'PublishAot' couldn't be inferred. Specify a rid explicitly. -->
    <AllowPublishAotWithoutRuntimeIdentifier Condition=" '$(AllowPublishAotWithoutRuntimeIdentifier)' == '' ">true</AllowPublishAotWithoutRuntimeIdentifier>
    <!-- NativeAOT's targets currently gives an error about cross-compilation -->
    <DisableUnsupportedError Condition=" $([MSBuild]::IsOSPlatform('windows')) and '$(DisableUnsupportedError)' == '' ">true</DisableUnsupportedError>
    <!-- HACK: make dotnet restore include Microsoft.NETCore.App.Runtime.NativeAOT.linux-bionic-arm64 -->
    <_IsPublishing Condition=" '$(_IsPublishing)' == '' ">true</_IsPublishing>
    <!-- Enable ILC metadata log for filtering marshal methods based on surviving types -->
    <IlcGenerateMetadataLog Condition=" '$(IlcGenerateMetadataLog)' == '' ">true</IlcGenerateMetadataLog>
    <!-- HACK: Bypass gc-sections by setting LinkerFlavor to a non-matching value.
         This is needed to keep crypto symbols from being stripped.
         The runtime's gc-sections condition checks for '', 'bfd', or 'lld'. -->
    <LinkerFlavor>android</LinkerFlavor>
  </PropertyGroup>

  <!-- Add the crypto library's JNI init function so it gets called during JNI_OnLoad.
       This initializes the crypto library with the JavaVM pointer so it can call JNI.
       Always include this - the crypto library is always linked for NativeAOT. -->
  <ItemGroup>
    <AndroidStaticJniInitFunction Include="AndroidCryptoNative_InitLibraryOnLoad" />
  </ItemGroup>

  <!-- Default property values for NativeAOT Debug configuration -->
  <PropertyGroup Condition="'$(DebugSymbols)' == 'true'">
    <NativeDebugSymbols>true</NativeDebugSymbols>
    <StripSymbols>false</StripSymbols>
    <CompressSymbols>false</CompressSymbols>
  </PropertyGroup>

  <!-- Default feature switches -->
  <ItemGroup>
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsMonoRuntime"
        Value="false"
        Trim="true"
    />
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsCoreClrRuntime"
        Value="false"
        Trim="true"
    />
    <RuntimeHostConfigurationOption Include="Microsoft.Android.Runtime.RuntimeFeature.IsNativeAotRuntime"
        Value="true"
        Trim="true"
    />
  </ItemGroup>

  <!-- For NativeAOT, populate ResolvedAssemblies (the input to _PrepareAssemblies) with the 
       actual assemblies for manifest generation. Since ILLink is disabled for NativeAOT 
       (ILC does its own trimming), _LinkAssemblies doesn't run, and we need to manually 
       populate the assemblies for GenerateJavaStubs to use.
       
       This target runs before _PrepareAssemblies, populating the @(ResolvedAssemblies) item group
       with assemblies from the runtime packs for proper type resolution.
       We need the implementation assemblies (from runtimes/.../lib/) not reference assemblies (from /ref/) 
       for GenerateJavaStubs to walk type hierarchies. -->
  <Target Name="_PopulateNativeAotAssemblies"
      BeforeTargets="_PrepareAssemblies"
      AfterTargets="_ResolveAssemblies">
    
    <!-- Determine the ABI based on runtime identifier -->
    <PropertyGroup>
      <_NativeAotAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' ">arm64-v8a</_NativeAotAbi>
      <_NativeAotAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm' ">armeabi-v7a</_NativeAotAbi>
      <_NativeAotAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' ">x86_64</_NativeAotAbi>
      <_NativeAotAbi Condition=" '$(RuntimeIdentifier)' == 'android-x86' ">x86</_NativeAotAbi>
      <!-- App assembly location - prefer IntermediateOutputPath (RID-specific) over _OuterIntermediateOutputPath -->
      <_NativeAotAppAssembly Condition=" Exists('$(IntermediateOutputPath)$(TargetName)$(TargetExt)') ">$(IntermediateOutputPath)$(TargetName)$(TargetExt)</_NativeAotAppAssembly>
      <_NativeAotAppAssembly Condition=" '$(_NativeAotAppAssembly)' == '' and Exists('$(_OuterIntermediateOutputPath)$(TargetName)$(TargetExt)') ">$(_OuterIntermediateOutputPath)$(TargetName)$(TargetExt)</_NativeAotAppAssembly>
    </PropertyGroup>
    
    <ItemGroup>
      <!-- Get the Android runtime pack path from ResolvedRuntimePack (set by ResolveFrameworkReferences) -->
      <_AndroidRuntimePackItem Include="@(ResolvedRuntimePack)" 
          Condition=" '%(ResolvedRuntimePack.NuGetPackageId)' != '' and $([System.String]::new('%(NuGetPackageId)').StartsWith('Microsoft.Android.Runtime.')) and !$([System.String]::new('%(NuGetPackageId)').Contains('NativeAOT')) " />
    </ItemGroup>

    <PropertyGroup>
      <_AndroidRuntimePackPath>@(_AndroidRuntimePackItem->'%(PackageDirectory)')</_AndroidRuntimePackPath>
      <_AndroidRuntimePackLibPath Condition=" '$(_AndroidRuntimePackPath)' != '' ">$(_AndroidRuntimePackPath)/runtimes/android/lib/net11.0/</_AndroidRuntimePackLibPath>
    </PropertyGroup>
    
    <ItemGroup>
      <!-- Add ALL Android runtime pack assemblies so the resolver can find types for attribute resolution -->
      <ResolvedAssemblies Include="$(_AndroidRuntimePackLibPath)*.dll"
          Condition=" '$(_AndroidRuntimePackLibPath)' != '' and Exists('$(_AndroidRuntimePackLibPath)') ">
        <Abi>$(_NativeAotAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
        <HasMonoAndroidReference>True</HasMonoAndroidReference>
      </ResolvedAssemblies>
      
      <!-- Add .NET reference assemblies for attribute type resolution (e.g., System.Runtime) -->
      <ResolvedAssemblies Include="@(ReferencePath)" 
          Condition=" '%(ReferencePath.Extension)' == '.dll' ">
        <Abi>$(_NativeAotAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
      </ResolvedAssemblies>

      <!-- Also include ResolvedFileToPublish assemblies if any exist (TypeMaps, Resource.Designer) -->
      <ResolvedAssemblies Include="@(ResolvedFileToPublish)" 
          Condition=" '%(ResolvedFileToPublish.Extension)' == '.dll' ">
        <Abi>$(_NativeAotAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
      </ResolvedAssemblies>
      
      <!-- Add app assembly from intermediate output -->
      <ResolvedAssemblies Include="$(_NativeAotAppAssembly)"
          Condition=" '$(_NativeAotAppAssembly)' != '' ">
        <Abi>$(_NativeAotAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
        <HasMonoAndroidReference>True</HasMonoAndroidReference>
        <TargetFrameworkIdentifier>MonoAndroid</TargetFrameworkIdentifier>
      </ResolvedAssemblies>
      
      <!-- User assemblies need to include the app -->
      <ResolvedUserAssemblies Include="$(_NativeAotAppAssembly)"
          Condition=" '$(_NativeAotAppAssembly)' != '' ">
        <Abi>$(_NativeAotAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
        <HasMonoAndroidReference>True</HasMonoAndroidReference>
        <TargetFrameworkIdentifier>MonoAndroid</TargetFrameworkIdentifier>
      </ResolvedUserAssemblies>
    </ItemGroup>

    <Message Importance="high" Text="[NativeAOT] App assembly: $(_NativeAotAppAssembly)" />
    <Message Importance="high" Text="[NativeAOT] Android runtime pack: $(_AndroidRuntimePackPath)" />
    <Message Importance="high" Text="[NativeAOT] Populated ResolvedAssemblies with @(ResolvedAssemblies->Count()) items for manifest generation" />
  </Target>

  <PropertyGroup>
    <IlcCompileDependsOn>
      _AndroidBeforeIlcCompile;
      SetupOSSpecificProps;
      ComputeIlcCompileInputs;
      _AndroidComputeIlcCompileInputs;
      $(IlcCompileDependsOn)
    </IlcCompileDependsOn>
  </PropertyGroup>

  <Target Name="_AndroidBeforeIlcCompile"
      DependsOnTargets="_GenerateTypeMapAssembly"
      BeforeTargets="SetupProperties">
    <!-- Example settings from: https://github.com/jonathanpeppers/Android-NativeAOT/blob/ea69d122cdc7de67aa6a5db14b7e560763c63cdd/DotNet/libdotnet.targets -->
    <PropertyGroup>
      <_NdkAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' ">aarch64</_NdkAbi>
      <_NdkAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' ">x86_64</_NdkAbi>
      <_NdkSysrootAbi>$(_NdkAbi)-linux-android</_NdkSysrootAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('windows')) ">windows-x86_64</_NdkPrebuiltAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('osx')) ">darwin-x86_64</_NdkPrebuiltAbi>
      <_NdkPrebuiltAbi Condition=" $([MSBuild]::IsOSPlatform('linux')) ">linux-x86_64</_NdkPrebuiltAbi>
      <_NdkSysrootDir>$(_AndroidNdkDirectory)toolchains/llvm/prebuilt/$(_NdkPrebuiltAbi)/sysroot/usr/lib/$(_NdkSysrootAbi)/</_NdkSysrootDir>
      <_NdkBinDir>$(_AndroidNdkDirectory)toolchains/llvm/prebuilt/$(_NdkPrebuiltAbi)/bin/</_NdkBinDir>
      <CppCompilerAndLinker>clang++</CppCompilerAndLinker>
      <ObjCopyName>llvm-objcopy</ObjCopyName>

      <!-- We must ensure this is `false`, as it would interfere with statically linking libc++ -->
      <LinkStandardCPlusPlusLibrary>false</LinkStandardCPlusPlusLibrary>

      <!-- DISABLE ILLink - NativeAOT ILC does its own whole-program trimming -->
      <RunILLink>false</RunILLink>
      <_RequiresILLink>false</_RequiresILLink>

      <!-- For TypeMap V3: Do NOT include legacy JAR files. All Java code is generated by GenerateTypeMapAssembly. -->
      <_RuntimeJar Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></_RuntimeJar>
      <MonoPlatformJarPath Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></MonoPlatformJarPath>

      <!-- For TypeMap V3 PoC: Disable R8/ProGuard - we don't have a way to determine which types survived ILC trimming yet -->
      <AndroidLinkTool Condition=" '$(AndroidEnableTypeMaps)' == 'true' "></AndroidLinkTool>
      
      <!-- For TypeMap V3: Tell ILC which assembly contains TypeMapAttribute entries -->
      <TypeMapEntryAssembly Condition=" '$(AndroidEnableTypeMaps)' == 'true' ">$(_TypeMapEntryAssemblyName)</TypeMapEntryAssembly>
    </PropertyGroup>

    <SetNdkPathForIlc NdkBinDirectory="$(_NdkBinDir)" />
  </Target>

  <Target Name="_AndroidComputeIlcCompileInputs"
      DependsOnTargets="_GenerateTypeMapAssembly">
    <ItemGroup>
      <!-- Android needs a proper soname property or it will refuse to load the library -->
      <LinkerArg Include="&quot;-Wl,-soname,lib$(TargetName)$(NativeBinaryExt)&quot;" />
      <LinkerArg Include="-Wl,--error-unresolved-symbols" />
      <LinkerArg Include="-Wl,--no-undefined" />

      <!-- Required for [UnmanagedCallersOnly] to work inside this assembly -->
      <UnmanagedEntryPointsAssembly Include="Microsoft.Android.Runtime.NativeAOT" />
      
      <!-- Give UNTRIMMED assemblies directly to ILC - ILC does its own trimming -->
      <!-- Use _OuterIntermediateOutputPath for the app assembly (from outer non-RID build) -->
      <IlcCompileInput Remove="@(IlcCompileInput)" />
      <IlcCompileInput Include="$(_OuterIntermediateOutputPath)$(TargetName)$(TargetExt)" />
      
      <!-- Add TypeMaps assembly as a ROOT assembly (IlcCompileInput), not just a reference.
           This ensures ILC includes it even if nothing directly references it.
           The assembly is needed at runtime for type mapping. -->
      <IlcCompileInput Include="@(_TypeMapGeneratedAssembly)" Condition=" '$(AndroidEnableTypeMaps)' == 'true' " />
      
      <!-- Satellite assemblies -->
      <IlcSatelliteAssembly Include="$(_OuterIntermediateSatelliteAssembliesWithTargetPath)" />

      <_NdkLibs Include="@(RuntimePackAsset->WithMetadataValue('Filename', 'libnaot-android.$(Configuration.ToLower())-static-$(Configuration.ToLower())'))" />

      <!-- Include libc++ -->
      <_NdkLibs Include="$(_NdkSysrootDir)libc++_static.a" />
      <_NdkLibs Include="$(_NdkSysrootDir)libc++abi.a" />

      <LinkerArg Include="&quot;%(_NdkLibs.Identity)&quot;" />

      <!-- This library conflicts with static libc++ -->
      <NativeLibrary Remove="$(IlcSdkPath)libstdc++compat.a" />
      <LinkerArg Remove="$(IlcSdkPath)libstdc++compat.a" />

      <!-- Every p/invoke using the `xa-internal-api` "library" will be called directly -->
      <DirectPInvoke Include="xa-internal-api" />
    </ItemGroup>
  </Target>

  <!-- Crypto library handling: use whole-archive to force all symbols to be included.
       The crypto symbols are not being pulled in by the normal link because the .NET code
       referencing them may be in sections that gc-sections eliminates.
       
       We add the crypto library a second time with whole-archive. The linker will see
       duplicate symbols, so we use allow-multiple-definition to let the first one win. -->
  <Target Name="_AndroidCryptoWholeArchive"
      AfterTargets="SetupOSSpecificProps"
      BeforeTargets="LinkNative">
    <PropertyGroup>
      <_CryptoLibPath>$(IlcFrameworkNativePath)libSystem.Security.Cryptography.Native.Android.a</_CryptoLibPath>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_CryptoLibPath)')">
      <!-- Re-add -fuse-ld=lld since LinkerFlavor is set to 'android' to bypass gc-sections.
           The last -fuse-ld flag wins, so this overrides the invalid 'android' one. -->
      <LinkerArg Include="-fuse-ld=lld" />
      <!-- Allow duplicate symbols since we're linking crypto twice -->
      <LinkerArg Include="-Wl,--allow-multiple-definition" />
      <!-- Add crypto with whole-archive to force all symbols to be included -->
      <LinkerArg Include="-Wl,--whole-archive" />
      <LinkerArg Include="&quot;$(_CryptoLibPath)&quot;" />
      <LinkerArg Include="-Wl,--no-whole-archive" />
      <!-- Use -z nostart-stop-gc to prevent stripping of encapsulation symbols -->
      <LinkerArg Include="-Wl,-z,nostart-stop-gc" />
    </ItemGroup>
    <Message Condition="Exists('$(_CryptoLibPath)')" Importance="high" Text="[NativeAOT] Using whole-archive for crypto: $(_CryptoLibPath)" />
  </Target>

  <Target Name="_PrepareNativeAotAndroidAppInputs">
    <ItemGroup>
      <_PrivateBuildTargetAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' " Include="arm64-v8a" />
      <_PrivateBuildTargetAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' " Include="x86_64" />
    </ItemGroup>

    <PrepareAbiItems
        BuildTargetAbis="@(_PrivateBuildTargetAbi)"
        NativeSourcesDir="$(_NativeAssemblySourceDir)"
        Debug="$(AndroidIncludeDebugSymbols)"
        Mode="jni_init">
      <Output TaskParameter="AssemblySources" ItemName="_PrivateJniInitFuncsAssemblySource" />
    </PrepareAbiItems>

    <PrepareAbiItems
        BuildTargetAbis="@(_PrivateBuildTargetAbi)"
        NativeSourcesDir="$(_NativeAssemblySourceDir)"
        Debug="$(AndroidIncludeDebugSymbols)"
        Mode="environment">
      <Output TaskParameter="AssemblySources" ItemName="_PrivateEnvironmentAssemblySource" />
    </PrepareAbiItems>

    <ItemGroup>
      <_PrivateJniInitFuncsNativeObjectFile Include="@(_PrivateJniInitFuncsAssemblySource->'$([System.IO.Path]::ChangeExtension('%(Identity)', '.o'))')">
        <abi>%(_PrivateJniInitFuncsAssemblySource.abi)</abi>
      </_PrivateJniInitFuncsNativeObjectFile>

      <_PrivateEnvironmentNativeObjectFile Include="@(_PrivateEnvironmentAssemblySource->'$([System.IO.Path]::ChangeExtension('%(Identity)', '.o'))')">
        <abi>%(_PrivateEnvironmentAssemblySource.abi)</abi>
      </_PrivateEnvironmentNativeObjectFile>

      <_PrivateAndroidNaotResolvedAssemblyFiles Include="@(ResolvedFileToPublish->Distinct())" Condition=" '%(ResolvedFileToPublish.Extension)' == '.dll' " />
    </ItemGroup>
  </Target>

  <Target
      Name="_GenerateNativeAotAndroidAppAssemblerSources"
      DependsOnTargets="_ResolveSdks;_GenerateEnvironmentFiles;_PrepareNativeAotAndroidAppInputs"
      Inputs="@(_PrivateAndroidNaotResolvedAssemblyFiles);@(AndroidEnvironment);@(LibraryEnvironments)"
      Outputs="@(_PrivateJniInitFuncsAssemblySource);@(_PrivateJniInitFuncsNativeObjectFile);@(_PrivateEnvironmentAssemblySource);@(_PrivateEnvironmentNativeObjectFile)">
    <GenerateNativeAotLibraryLoadAssemblerSources
        ResolvedAssemblies="@(_PrivateAndroidNaotResolvedAssemblyFiles)"
        CustomJniInitFunctions="@(AndroidStaticJniInitFunction)"
        OutputSources="@(_PrivateJniInitFuncsAssemblySource)" />

    <GenerateNativeAotEnvironmentAssemblerSources
        Environments="@(AndroidEnvironment);@(LibraryEnvironments)"
        HttpClientHandlerType="$(AndroidHttpClientHandlerType)"
        OutputSources="@(_PrivateEnvironmentAssemblySource)"
        RID="$(RuntimeIdentifier)" />

    <CompileNativeAssembly
        Sources="@(_PrivateJniInitFuncsAssemblySource);@(_PrivateEnvironmentAssemblySource)"
        DebugBuild="$(AndroidIncludeDebugSymbols)"
        WorkingDirectory="$(_NativeAssemblySourceDir)"
        AndroidBinUtilsDirectory="$(AndroidBinUtilsDirectory)" />

    <ItemGroup>
      <LinkerArg Include="@(_PrivateJniInitFuncsNativeObjectFile)" />
      <LinkerArg Include="@(_PrivateEnvironmentNativeObjectFile)" />
    </ItemGroup>
  </Target>

  <!-- Compile and link TypeMap V3 marshal methods for NativeAOT.
       These LLVM IR files define JNI native method stubs that need to be exported. -->
  <Target
      Name="_CompileTypeMapMarshalMethodsForNativeAot"
      BeforeTargets="LinkNative"
      AfterTargets="IlcCompile"
      DependsOnTargets="_ResolveSdks;_GenerateTypeMapAssembly"
      Condition=" '$(AndroidEnableTypeMaps)' == 'true' ">
    <PropertyGroup>
      <_AndroidMarshalMethodsDir>$(IntermediateOutputPath)android</_AndroidMarshalMethodsDir>
      <_IlcMetadataFile>$(IntermediateOutputPath)native$([System.IO.Path]::DirectorySeparatorChar)$(TargetName).metadata.csv</_IlcMetadataFile>
    </PropertyGroup>

    <!-- Collect the marshal method LLVM IR files -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSourceRaw Include="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_*.ll" />
    </ItemGroup>

    <!-- Set ABI metadata for compilation (NativeAOT currently only supports arm64) -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSource Include="@(_TypeMapMarshalMethodsSourceRaw)">
        <abi>arm64-v8a</abi>
      </_TypeMapMarshalMethodsSource>
    </ItemGroup>

    <!-- Compile .ll files to .o files -->
    <CompileNativeAssembly
        Sources="@(_TypeMapMarshalMethodsSource)"
        DebugBuild="$(AndroidIncludeDebugSymbols)"
        WorkingDirectory="$(_AndroidMarshalMethodsDir)"
        AndroidBinUtilsDirectory="$(AndroidBinUtilsDirectory)"
        Condition=" '@(_TypeMapMarshalMethodsSource)' != '' " />

    <Message Importance="High" Text="[TypeMap] Compiled @(_TypeMapMarshalMethodsSource->Count()) marshal method files" />

    <!-- Collect ALL object files (before filtering) -->
    <ItemGroup>
      <_TypeMapMarshalMethodsObjectFileAll Include="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_*.o">
        <abi>arm64-v8a</abi>
      </_TypeMapMarshalMethodsObjectFileAll>
    </ItemGroup>

    <!-- Define exports file path -->
    <PropertyGroup>
      <_TypeMapMarshalMethodsExportsFile>$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_exports.txt</_TypeMapMarshalMethodsExportsFile>
    </PropertyGroup>

    <!-- Filter object files based on ILC trimming results -->
    <FilterMarshalMethodsByIlcMetadata
        Condition=" Exists('$(_IlcMetadataFile)') "
        IlcMetadataFile="$(_IlcMetadataFile)"
        MarshalMethodObjectFiles="@(_TypeMapMarshalMethodsObjectFileAll)"
        MarshalMethodsExportsFile="$(_TypeMapMarshalMethodsExportsFile)">
      <Output TaskParameter="FilteredObjectFiles" ItemName="_TypeMapMarshalMethodsObjectFile" />
      <Output TaskParameter="FilteredExportsFile" PropertyName="_TypeMapMarshalMethodsExportsFileFiltered" />
    </FilterMarshalMethodsByIlcMetadata>

    <!-- If no metadata file, use all object files (non-NativeAOT case or fallback) -->
    <ItemGroup Condition=" !Exists('$(_IlcMetadataFile)') ">
      <_TypeMapMarshalMethodsObjectFile Include="@(_TypeMapMarshalMethodsObjectFileAll)" />
    </ItemGroup>
    <PropertyGroup Condition=" !Exists('$(_IlcMetadataFile)') ">
      <_TypeMapMarshalMethodsExportsFileFiltered>$(_TypeMapMarshalMethodsExportsFile)</_TypeMapMarshalMethodsExportsFileFiltered>
    </PropertyGroup>

    <Message Importance="High" Text="[TypeMap] Linking @(_TypeMapMarshalMethodsObjectFile->Count()) filtered object files (from @(_TypeMapMarshalMethodsObjectFileAll->Count()) total)" />

    <!-- Add filtered object files to LinkerArg -->
    <ItemGroup>
      <LinkerArg Include="@(_TypeMapMarshalMethodsObjectFile)" />
    </ItemGroup>

    <!-- Append filtered marshal method symbols to ILC exports file -->
    <AppendMarshalMethodExports
        Condition=" Exists('$(_TypeMapMarshalMethodsExportsFileFiltered)') and Exists('$(ExportsFile)') "
        MarshalMethodsExportsFile="$(_TypeMapMarshalMethodsExportsFileFiltered)"
        ExportsFile="$(ExportsFile)" />
    <Message Importance="High"
             Condition=" Exists('$(_TypeMapMarshalMethodsExportsFileFiltered)') "
             Text="[TypeMap] Appended filtered marshal method exports from $(_TypeMapMarshalMethodsExportsFileFiltered)" />

    <!-- Append crypto JNI callback symbols to exports file.
         The libSystem.Security.Cryptography.Native.Android library has Java classes that 
         call back to native code. These JNI symbols must be exported. -->
    <PropertyGroup>
      <_CryptoExportsFile>$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)crypto_exports.txt</_CryptoExportsFile>
    </PropertyGroup>
    <ItemGroup>
      <_CryptoExportSymbol Include="Java_net_dot_android_crypto_DotnetProxyTrustManager_verifyRemoteCertificate" />
    </ItemGroup>
    <WriteLinesToFile
        Condition=" Exists('$(ExportsFile)') "
        File="$(_CryptoExportsFile)"
        Lines="@(_CryptoExportSymbol)"
        Overwrite="true" />
    <AppendMarshalMethodExports
        Condition=" Exists('$(_CryptoExportsFile)') and Exists('$(ExportsFile)') "
        MarshalMethodsExportsFile="$(_CryptoExportsFile)"
        ExportsFile="$(ExportsFile)" />
    <Message Importance="High"
             Condition=" Exists('$(_CryptoExportsFile)') "
             Text="[NativeAOT] Added crypto JNI callback symbols to exports" />
  </Target>

  <!-- Make sure we have a chance to generate our application-specific static library before linking
       takes place. We must run after `IlcCompile`, which is a dependency of `LinkNative`  -->
  <Target
      Name="_GenerateNativeAotAndroidAppLibrary"
      AfterTargets="IlcCompile"
      DependsOnTargets="_GenerateNativeAotAndroidAppAssemblerSources">
  </Target>

  <Target Name="_AndroidFixNativeLibraryFileName" AfterTargets="ComputeFilesToPublish">
    <ItemGroup>
      <!-- Fix paths to contain lib-prefix -->
      <ResolvedFileToPublish Update="@(ResolvedFileToPublish)" ArchiveFileName="lib%(FileName)%(Extension)" Condition=" '%(Filename)%(Extension)' == '$(TargetName)$(NativeBinaryExt)' " />
    </ItemGroup>
  </Target>

  <!-- Generate proguard keep rules for NativeAOT builds.
       Unlike ILLink-based builds, we generate keep rules directly from the TypeMaps assembly
       without waiting for ILLink to run (ILC does its own trimming). -->
  <Target Name="_GenerateProguardFromTypeMapForNativeAot"
      AfterTargets="_GenerateTypeMapAssembly"
      BeforeTargets="_CalculateProguardConfigurationFiles"
      Condition=" '$(AndroidEnableTypeMaps)' == 'true' and '$(AndroidLinkTool)' != '' ">
    <PropertyGroup>
      <!-- TypeMaps assembly is generated by _GenerateTypeMapAssembly in _TypeMapBaseOutputDir -->
      <!-- Match the path from Microsoft.Android.Sdk.ILLink.targets -->
      <_TypeMapBaseOutputDir>$(BaseIntermediateOutputPath)$(Configuration)$([System.IO.Path]::DirectorySeparatorChar)$(TargetFramework)$([System.IO.Path]::DirectorySeparatorChar)</_TypeMapBaseOutputDir>
      <_TypeMapAssemblyFileName>_Microsoft.Android.TypeMaps.dll</_TypeMapAssemblyFileName>
      <_TypeMapAssemblyPath>$(_TypeMapBaseOutputDir)typemap$([System.IO.Path]::DirectorySeparatorChar)$(_TypeMapAssemblyFileName)</_TypeMapAssemblyPath>
      <_TypeMapProguardConfig>$(IntermediateOutputPath)proguard$([System.IO.Path]::DirectorySeparatorChar)proguard_typemap.cfg</_TypeMapProguardConfig>
    </PropertyGroup>
    <MakeDir Directories="$(IntermediateOutputPath)proguard" />
    <GenerateProguardFromTypeMap
        Condition=" Exists('$(_TypeMapAssemblyPath)') "
        TypeMapsAssembly="$(_TypeMapAssemblyPath)"
        OutputProguardConfiguration="$(_TypeMapProguardConfig)"
        Enabled="true" />
    <!-- Add to proguard configuration files -->
    <ItemGroup Condition=" Exists('$(_TypeMapProguardConfig)') ">
      <ProguardConfiguration Include="$(_TypeMapProguardConfig)" />
    </ItemGroup>
    <Warning Condition=" !Exists('$(_TypeMapAssemblyPath)') "
             Text="TypeMaps assembly not found for proguard generation: $(_TypeMapAssemblyPath)" />
  </Target>

  <!-- NativeAOT with TypeMap V3 NEEDS java-interop.jar for peer creation.
       Unlike MonoVM TypeMap V3, NativeAOT uses Java.Interop directly and requires:
       - ManagedPeer: for registerNativeMembers and peer construction
       - JavaProxyThrowable/JavaProxyObject: for exception and object proxies
       The target that was previously removing these JARs has been removed. -->

  <!-- Include System.Security.Cryptography.Native.Android JAR for SSL/TLS support.
       This JAR contains Java classes needed for Android crypto interop (DotnetProxyTrustManager, etc.).
       The native library is linked via ILC but the Java classes are needed at runtime.
       The JAR is located in the NativeAOT runtime pack.
       
       TODO: Future optimization - only include crypto JAR/dex if System.Net.Security.SslStream 
       survives ILC trimming. This requires checking ILC metadata.csv after IlcCompile. -->
  <Target Name="_IncludeCryptoJarForNativeAot"
      AfterTargets="ComputeIlcCompileInputs"
      BeforeTargets="_DetermineJavaLibrariesToCompile;IlcCompile">
    <PropertyGroup>
      <!-- Use IlcFrameworkNativePath which is set during ILC compile.
           Store it in a persistent property so subsequent target runs can use it. -->
      <_CryptoJarNativePath Condition=" '$(IlcFrameworkNativePath)' != '' ">$(IlcFrameworkNativePath)</_CryptoJarNativePath>
      <_CryptoJarPath Condition=" '$(_CryptoJarNativePath)' != '' ">$(_CryptoJarNativePath)libSystem.Security.Cryptography.Native.Android.jar</_CryptoJarPath>
    </PropertyGroup>
    <ItemGroup Condition=" '$(_CryptoJarPath)' != '' and Exists('$(_CryptoJarPath)') ">
      <AndroidJavaLibrary Include="$(_CryptoJarPath)" />
    </ItemGroup>
    <Message Condition=" '$(_CryptoJarPath)' != '' and Exists('$(_CryptoJarPath)') " Importance="high" Text="[NativeAOT] Added crypto JAR: $(_CryptoJarPath)" />
    <!-- Only warn if we tried to find the JAR but it wasn't there -->
    <Warning Condition=" '$(_CryptoJarPath)' != '' and !Exists('$(_CryptoJarPath)') " Text="[NativeAOT] Crypto JAR not found: $(_CryptoJarPath). SSL/TLS may not work." />
  </Target>

  <!-- TODO: Include only the specific JCWs from mono.android.jar that NativeAOT needs
       (e.g., FakeSSLSession for SSL hostname verification). Currently commented out
       because mono.android.jar duplicates classes already in java-interop.jar.
       For now, skip hostname verification for self-signed certs. -->

  <!-- Add ProGuard keep rules for crypto classes.
       The crypto JAR contains classes that are called via JNI from native code,
       so R8 cannot detect that they are used and would strip them. -->
  <Target Name="_AddCryptoProguardRulesForNativeAot"
      AfterTargets="_IncludeCryptoJarForNativeAot"
      BeforeTargets="_CalculateProguardConfigurationFiles"
      Condition=" '$(AndroidLinkTool)' != '' ">
    <PropertyGroup>
      <_CryptoProguardConfig>$(IntermediateOutputPath)proguard$([System.IO.Path]::DirectorySeparatorChar)proguard_crypto.cfg</_CryptoProguardConfig>
    </PropertyGroup>
    <MakeDir Directories="$(IntermediateOutputPath)proguard" />
    <!-- Generate keep rules for crypto classes -->
    <WriteLinesToFile
        File="$(_CryptoProguardConfig)"
        Lines="# Keep crypto classes used by System.Security.Cryptography.Native.Android;-keep class net.dot.android.crypto.** { *%3B }"
        Overwrite="true" />
    <ItemGroup>
      <ProguardConfiguration Include="$(_CryptoProguardConfig)" />
    </ItemGroup>
    <Message Importance="high" Text="[NativeAOT] Added crypto ProGuard rules: $(_CryptoProguardConfig)" />
  </Target>

</Project>
