<!--
***********************************************************************************************
Microsoft.Android.Sdk.ILLink.targets

This file contains the .NET 5-specific targets to customize ILLink

***********************************************************************************************
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <UsingTask TaskName="Xamarin.Android.Tasks.GenerateTypeMapAssembly" AssemblyFile="$(_XamarinAndroidBuildTasksAssembly)" />

  <!--
    Generate the TypeMap assembly BEFORE ILLink runs.
    This task scans assemblies for [Register] attributes and generates _Microsoft.Android.TypeMaps.dll
    containing TypeMapAttribute entries. The generated assembly is included in the ILLink input
    so that type mappings affect trimming decisions.
  -->
  <Target Name="_GenerateTypeMapAssembly"
      AfterTargets="_ResolveAssemblies"
      BeforeTargets="_GenerateJavaStubs"
      Condition=" '$(AndroidUseTrimmableTypeMap)' == 'true' and '@(ReferencePath)' != '' ">
    <PropertyGroup>
      <!-- Use BaseIntermediateOutputPath to ensure LLVM IR files are in a consistent location
           accessible from both outer build and per-RID builds -->
      <_TypeMapBaseOutputDir>$(BaseIntermediateOutputPath)$(Configuration)\$(TargetFramework)\</_TypeMapBaseOutputDir>
      <_TypeMapAssemblyOutputDir>$(_TypeMapBaseOutputDir)typemap\</_TypeMapAssemblyOutputDir>
      <_TypeMapJavaSourceOutputDir>$(_AndroidIntermediateJavaSourceDirectory)</_TypeMapJavaSourceOutputDir>
      <!-- Use IntermediateOutputPath (RID-specific) for LLVM IR files so they're in the same dir as other .ll files -->
      <_TypeMapLlvmIrOutputDir>$(IntermediateOutputPath)android\</_TypeMapLlvmIrOutputDir>
    </PropertyGroup>
    
    <!-- Build list of assemblies to scan: use ResolvedAssemblies from _ResolveAssemblies,
         plus ResolvedFrameworkAssemblies which includes Mono.Android -->
    <Warning Text="[GTMA DEBUG] ResolvedAssemblies count: @(ResolvedAssemblies->Count())" />
    <Warning Text="[GTMA DEBUG] ResolvedFrameworkAssemblies count: @(ResolvedFrameworkAssemblies->Count())" />
    <Warning Text="[GTMA DEBUG] ReferencePath count: @(ReferencePath->Count())" />
    <Warning Text="[GTMA DEBUG] ReferencePath: @(ReferencePath->'%(FileName)')" />
    <Warning Text="[GTMA DEBUG] App assembly: $(IntermediateOutputPath)$(TargetFileName)" />
    <Warning Text="[GTMA DEBUG] App assembly exists: $([System.IO.File]::Exists('$(IntermediateOutputPath)$(TargetFileName)'))" />
    <ItemGroup>
      <_TypeMapInputAssemblies Include="@(ResolvedAssemblies)" />
      <_TypeMapInputAssemblies Include="@(ResolvedFrameworkAssemblies)" />
      <!-- Also include ReferencePath which has framework assemblies in the outer build -->
      <_TypeMapInputAssemblies Include="@(ReferencePath)" />
      <_TypeMapInputAssemblies Include="$(IntermediateOutputPath)$(TargetFileName)" Condition="Exists('$(IntermediateOutputPath)$(TargetFileName)')" />
    </ItemGroup>
    
    <Message Importance="high" Text="[GTMA] ResolvedAssemblies count: @(ResolvedAssemblies->Count())" />
    <Message Importance="high" Text="[GTMA] _XamarinAndroidBuildTasksAssembly: $(_XamarinAndroidBuildTasksAssembly)" />
    <Message Importance="high" Text="[GTMA] _TypeMapInputAssemblies count: @(_TypeMapInputAssemblies->Count())" />
    <Message Importance="high" Text="[GTMA] Input assemblies: @(_TypeMapInputAssemblies->'%(FileName)')" Condition=" '@(_TypeMapInputAssemblies->Count())' != '0' " />
    
    <GenerateTypeMapAssembly
        ResolvedAssemblies="@(_TypeMapInputAssemblies)"
        OutputDirectory="$(_TypeMapAssemblyOutputDir)"
        JavaSourceOutputDirectory="$(_TypeMapJavaSourceOutputDir)"
        LlvmIrOutputDirectory="$(_TypeMapLlvmIrOutputDir)"
        CustomViewMapFile="$(_OuterCustomViewMapFile)"
        ErrorOnCustomJavaObject="$(AndroidErrorOnCustomJavaObject)">
      <Output TaskParameter="GeneratedAssembly" ItemName="_TypeMapGeneratedAssembly" />
      <Output TaskParameter="TypeMapEntryAssemblyName" PropertyName="_TypeMapEntryAssemblyName" />
      <Output TaskParameter="UpdatedResolvedAssemblies" ItemName="_TypeMapUpdatedAssemblies" />
      <Output TaskParameter="GeneratedJavaFiles" ItemName="_GeneratedJavaFiles" />
    </GenerateTypeMapAssembly>

    <!-- Update TypeMapEntryAssembly to point to the generated assembly -->
    <PropertyGroup Condition=" '$(_TypeMapEntryAssemblyName)' != '' ">
      <TypeMapEntryAssembly>$(_TypeMapEntryAssemblyName)</TypeMapEntryAssembly>
    </PropertyGroup>

    <!-- Add the generated TypeMaps assembly to ManagedAssemblyToLink so ILLink processes it.
         ILLink uses the typemap-entry-assembly flag to know which assembly contains TypeMapAttribute entries
         and will trim unused proxy types based on the 3-arg TypeMapAttribute trimTarget parameter. -->
    <ItemGroup Condition=" '@(_TypeMapGeneratedAssembly)' != '' ">
      <ManagedAssemblyToLink Include="@(_TypeMapGeneratedAssembly)" />
    </ItemGroup>

    <!-- Add the TypeMaps assembly to ResolvedFileToPublish for trimmed builds -->
    <ItemGroup Condition=" '@(_TypeMapGeneratedAssembly)' != '' ">
      <ResolvedFileToPublish Include="@(_TypeMapGeneratedAssembly)" />
    </ItemGroup>

    <!-- Create empty .jlo.xml and .typemap.xml files so GenerateJavaStubs doesn't fail -->
    <ItemGroup Condition=" '@(_TypeMapGeneratedAssembly)' != '' ">
      <_TypeMapGeneratedAssemblyArtifacts Include="@(_TypeMapGeneratedAssembly)">
        <JloPath>%(RootDir)%(Directory)%(Filename).jlo.xml</JloPath>
        <TypeMapPath>%(RootDir)%(Directory)%(Filename).typemap.xml</TypeMapPath>
      </_TypeMapGeneratedAssemblyArtifacts>
    </ItemGroup>
    <WriteLinesToFile Condition=" '@(_TypeMapGeneratedAssemblyArtifacts)' != '' and !Exists('%(_TypeMapGeneratedAssemblyArtifacts.JloPath)') "
                      File="%(_TypeMapGeneratedAssemblyArtifacts.JloPath)"
                      Lines="&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;api /&gt;"
                      Overwrite="true" />
    <WriteLinesToFile Condition=" '@(_TypeMapGeneratedAssemblyArtifacts)' != '' and !Exists('%(_TypeMapGeneratedAssemblyArtifacts.TypeMapPath)') "
                      File="%(_TypeMapGeneratedAssemblyArtifacts.TypeMapPath)"
                      Lines=""
                      Overwrite="true" />

    <Message Condition=" '@(_TypeMapGeneratedAssembly)' != '' " Importance="high" 
             Text="Generated TypeMap assembly: @(_TypeMapGeneratedAssembly) (TypeMapEntryAssembly=$(TypeMapEntryAssembly))" />
  </Target>

  <!-- 
    Add the TypeMaps assembly to ResolvedAssemblies with proper ABI metadata.
    This runs after _GenerateTypeMapAssembly when RuntimeIdentifier is available.
    We require RuntimeIdentifier to be set to properly map to ABI.
  -->
  <Target Name="_AddTypeMapAssemblyToResolvedAssemblies"
      AfterTargets="_GenerateTypeMapAssembly"
      BeforeTargets="_PrepareAssemblies;_GenerateJavaStubs;_CopyAssemblies"
      Condition=" '$(AndroidUseTrimmableTypeMap)' == 'true' and '@(_TypeMapGeneratedAssembly)' != '' and '$(RuntimeIdentifier)' != '' ">
    
    <PropertyGroup>
      <!-- Map RuntimeIdentifier to Abi -->
      <_TypeMapAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm64' ">arm64-v8a</_TypeMapAbi>
      <_TypeMapAbi Condition=" '$(RuntimeIdentifier)' == 'android-arm' ">armeabi-v7a</_TypeMapAbi>
      <_TypeMapAbi Condition=" '$(RuntimeIdentifier)' == 'android-x64' ">x86_64</_TypeMapAbi>
      <_TypeMapAbi Condition=" '$(RuntimeIdentifier)' == 'android-x86' ">x86</_TypeMapAbi>
      <!-- Check if already added -->
      <_TypeMapAlreadyInResolvedAssemblies>@(_ResolvedAssemblies->AnyHaveMetadataValue('Filename', '_Microsoft.Android.TypeMaps'))</_TypeMapAlreadyInResolvedAssemblies>
    </PropertyGroup>

    <ItemGroup Condition=" '$(_TypeMapAlreadyInResolvedAssemblies)' != 'true' ">
      <_ResolvedAssemblies Include="@(_TypeMapGeneratedAssembly)">
        <Abi>$(_TypeMapAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
        <DestinationSubDirectory>$(_TypeMapAbi)\</DestinationSubDirectory>
        <DestinationSubPath>_Microsoft.Android.TypeMaps.dll</DestinationSubPath>
      </_ResolvedAssemblies>
      <ResolvedAssemblies Include="@(_TypeMapGeneratedAssembly)">
        <Abi>$(_TypeMapAbi)</Abi>
        <RuntimeIdentifier>$(RuntimeIdentifier)</RuntimeIdentifier>
        <DestinationSubDirectory>$(_TypeMapAbi)\</DestinationSubDirectory>
        <DestinationSubPath>_Microsoft.Android.TypeMaps.dll</DestinationSubPath>
      </ResolvedAssemblies>
    </ItemGroup>
    
    <Message Importance="high" Text="[TypeMap] Added TypeMaps assembly with Abi=$(_TypeMapAbi) RuntimeIdentifier=$(RuntimeIdentifier)" 
             Condition=" '$(_TypeMapAlreadyInResolvedAssemblies)' != 'true' " />
    <Message Importance="high" Text="[TypeMap] TypeMaps assembly already in _ResolvedAssemblies, skipping" 
             Condition=" '$(_TypeMapAlreadyInResolvedAssemblies)' == 'true' " />
  </Target>

  <Target Name="_PrepareLinking"
      Condition=" '$(PublishTrimmed)' == 'true' "
      AfterTargets="ComputeResolvedFilesToPublishList"
      DependsOnTargets="GetReferenceAssemblyPaths;_CreatePropertiesCache;_GenerateTypeMapAssembly">
    <PropertyGroup>
      <TrimmerRemoveSymbols Condition=" '$(AndroidIncludeDebugSymbols)' != 'true' ">true</TrimmerRemoveSymbols>
      <_ExtraTrimmerArgs Condition=" '$(_EnableSerializationDiscovery)' != 'false' ">--enable-serialization-discovery $(_ExtraTrimmerArgs)</_ExtraTrimmerArgs>
      <_ExtraTrimmerArgs Condition=" '$(_AndroidEnableUnusedTypeChecks)' != 'true' ">--disable-opt unusedtypechecks $(_ExtraTrimmerArgs)</_ExtraTrimmerArgs>
      <!-- TypeMapEntryAssembly is set by _GenerateTypeMapAssembly, or defaults to Mono.Android for MonoVM -->
      <TypeMapEntryAssembly Condition=" '$(TypeMapEntryAssembly)' == '' ">Mono.Android</TypeMapEntryAssembly>
      <!-- Pass the TypeMap entry assembly to ILLink so it can populate TypeMapping dictionaries (dotnet/runtime#121513) -->
      <_ExtraTrimmerArgs>--typemap-entry-assembly $(TypeMapEntryAssembly) $(_ExtraTrimmerArgs)</_ExtraTrimmerArgs>
      <!--
        Used for the <ILLink DumpDependencies="$(_TrimmerDumpDependencies)" /> value:
        https://github.com/dotnet/sdk/blob/a5393731b5b7b225692fff121f747fbbc9e8b140/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.ILLink.targets#L150
        -->
      <_TrimmerDumpDependencies Condition=" '$(LinkerDumpDependencies)' == 'true' ">true</_TrimmerDumpDependencies>
      <_AndroidLinkerCustomStepAssembly>$(MSBuildThisFileDirectory)..\tools\Microsoft.Android.Sdk.ILLink.dll</_AndroidLinkerCustomStepAssembly>
      <_SystemIOHashingAssemblyPath>$(MSBuildThisFileDirectory)..\tools\System.IO.Hashing.dll</_SystemIOHashingAssemblyPath>
      <_ProguardProjectConfiguration Condition=" '$(AndroidLinkTool)' != '' ">$(IntermediateOutputPath)proguard\proguard_project_references.cfg</_ProguardProjectConfiguration>
    </PropertyGroup>
    <ItemGroup>
      <!--
        Used for the <ILLink CustomData="@(_TrimmerCustomData)" /> value:
        https://github.com/dotnet/sdk/blob/a5393731b5b7b225692fff121f747fbbc9e8b140/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.ILLink.targets#L147
        -->
      <_TrimmerCustomData Include="AndroidHttpClientHandlerType" Value="$(AndroidHttpClientHandlerType)" />
      <_TrimmerCustomData Include="AndroidCustomViewMapFile" Value="$(_OuterCustomViewMapFile)" />
      <_TrimmerCustomData
          Condition=" '$(_ProguardProjectConfiguration)' != '' "
          Include="ProguardConfiguration"
          Value="$(_ProguardProjectConfiguration)"
      />
      <_TrimmerCustomData Include="SystemIOHashingAssemblyPath" Value="$(_SystemIOHashingAssemblyPath)" />
      <!-- TypeMap: Output path for LLVM IR generation (JCW is handled by GenerateJavaStubs) -->
      <_TrimmerCustomData Condition=" '$(AndroidUseTrimmableTypeMap)' == 'true' and '$(TypeMapEntryAssembly)' != '' " Include="LlvmIrOutputPath" Value="$(_TypeMapLlvmIrOutputDir)" />
      <_TrimmerCustomData Condition=" '$(RuntimeIdentifier)' != '' " Include="TargetArch" Value="$(RuntimeIdentifier)" />
      <!-- TypeMap assembly name - the ILLink step reads type mapping info from this assembly -->
      <_TrimmerCustomData Condition=" '$(TypeMapEntryAssembly)' != '' " Include="TypeMapEntryAssembly" Value="$(TypeMapEntryAssembly)" />

      <!--
        Used for the <ILLink CustomSteps="@(_TrimmerCustomSteps)" /> value:
        https://github.com/dotnet/sdk/blob/a5393731b5b7b225692fff121f747fbbc9e8b140/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.ILLink.targets#L131
        -->
      <!-- add our custom steps -->
      <!-- Custom MarkHandlers that run during MarkStep -->
      <!-- DISABLED: MarkJavaObjects and Preserve* steps replaced by TypeMapAttribute preservation strategy
           See type-mapping-api-v3-spec.md for details on how preservation is now handled:
           - JCW types (DoNotGenerateAcw=false) use 2-arg unconditional TypeMapAttribute
           - MCW types (DoNotGenerateAcw=true) use 3-arg trimmable TypeMapAttribute
           - Proxy types directly reference activation ctors, string ctors, and interface methods
           See also: Documentation/guides/illink-constructor-marking-limitation.md
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="Microsoft.Android.Sdk.ILLink.PreserveSubStepDispatcher" />
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="MonoDroid.Tuner.MarkJavaObjects" />
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="MonoDroid.Tuner.PreserveJavaExceptions" />
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="MonoDroid.Tuner.PreserveApplications" />
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="Microsoft.Android.Sdk.ILLink.PreserveRegistrations" />
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="Microsoft.Android.Sdk.ILLink.PreserveJavaInterfaces" />
      -->
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" Type="MonoDroid.Tuner.FixAbstractMethodsStep" />
      <!-- Custom steps that run after MarkStep -->
      <!-- GenerateProguardConfiguration: Generates keep rules during ILLink.
           When using Trimmable TypeMap, we use _GenerateProguardFromTypeMap MSBuild task instead,
           which runs after ILLink completes and reads the linked TypeMaps assembly. -->
      <_TrimmerCustomSteps
          Condition=" '$(_ProguardProjectConfiguration)' != '' and '$(AndroidUseTrimmableTypeMap)' != 'true' "
          Include="$(_AndroidLinkerCustomStepAssembly)"
          AfterStep="CleanStep"
          Type="Mono.Linker.Steps.GenerateProguardConfiguration"
      />
      <_TrimmerCustomSteps
          Condition=" '$(AndroidAddKeepAlives)' == 'true' "
          Include="$(_AndroidLinkerCustomStepAssembly)"
          AfterStep="CleanStep"
          Type="MonoDroid.Tuner.AddKeepAlivesStep"
      />
      <!-- Custom steps that run after CleanStep -->
      <_TrimmerCustomSteps Include="$(_AndroidLinkerCustomStepAssembly)" AfterStep="CleanStep" Type="MonoDroid.Tuner.StripEmbeddedLibraries" />
      <_TrimmerCustomSteps
          Condition=" '$(AndroidLinkResources)' == 'true' "
          Include="$(_AndroidLinkerCustomStepAssembly)"
          AfterStep="CleanStep"
          Type="MonoDroid.Tuner.RemoveResourceDesignerStep"
      />
      <_TrimmerCustomSteps
          Condition=" '$(AndroidLinkResources)' == 'true' "
          Include="$(_AndroidLinkerCustomStepAssembly)"
          AfterStep="CleanStep"
          Type="MonoDroid.Tuner.GetAssembliesStep"
      />
      <_TrimmerCustomSteps
          Condition=" '$(AndroidUseDesignerAssembly)' == 'true' "
          Include="$(_AndroidLinkerCustomStepAssembly)"
          BeforeStep="MarkStep"
          Type="MonoDroid.Tuner.FixLegacyResourceDesignerStep"
      />

      <TrimmerRootDescriptor Include="$(MSBuildThisFileDirectory)..\PreserveLists\*.xml" />
      <TrimmerRootDescriptor Include="@(LinkDescription)" />
      <TrimmerRootAssembly Include="Microsoft.Android.Runtime.NativeAOT" Condition=" '$(_AndroidRuntime)' == 'NativeAOT' " RootMode="All" />
    </ItemGroup>
  </Target>

  <Target Name="_FixRootAssembly" AfterTargets="PrepareForILLink">
    <ItemGroup>
      <TrimmerRootAssembly Update="@(TrimmerRootAssembly)" Condition=" '%(RootMode)' == 'EntryPoint' " RootMode="All" />
    </ItemGroup>
  </Target>

  <Target Name="_LinkAssemblies"
      DependsOnTargets="_ResolveAssemblies;_CreatePackageWorkspace;$(_BeforeLinkAssemblies);_GenerateJniMarshalMethods;_LinkAssembliesNoShrink"
  />

  <Target Name="_TouchAndroidLinkFlag"
      AfterTargets="ILLink"
      Condition=" '$(PublishTrimmed)' == 'true' and Exists('$(_LinkSemaphore)') "
      Inputs="$(_LinkSemaphore)"
      Outputs="$(_AndroidLinkFlag)">
    <!-- This file is an input for _RemoveRegisterAttribute -->
    <Touch Files="$(_AndroidLinkFlag)" AlwaysCreate="true" />
  </Target>

  <!-- After ILLink runs, add the linked TypeMaps assembly to ResolvedFileToPublish.
       ILLink copies the assembly to IntermediateLinkDir, so we need to reference that location. -->
  <Target Name="_AddLinkedTypeMapAssemblyToPublish"
      AfterTargets="ILLink"
      Condition=" '$(PublishTrimmed)' == 'true' and '$(AndroidUseTrimmableTypeMap)' == 'true' ">
    <PropertyGroup>
      <!-- TypeMaps assembly is generated to a well-known location, compute the linked path from properties -->
      <_TypeMapAssemblyFileName>_Microsoft.Android.TypeMaps.dll</_TypeMapAssemblyFileName>
      <_LinkedTypeMapAssemblyPath>$(IntermediateLinkDir)$(_TypeMapAssemblyFileName)</_LinkedTypeMapAssemblyPath>
      <_LinkedTypeMapJloXmlPath>$(IntermediateLinkDir)_Microsoft.Android.TypeMaps.jlo.xml</_LinkedTypeMapJloXmlPath>
      <_LinkedTypeMapTypemapXmlPath>$(IntermediateLinkDir)_Microsoft.Android.TypeMaps.typemap.xml</_LinkedTypeMapTypemapXmlPath>
    </PropertyGroup>
    <ItemGroup Condition=" Exists('$(_LinkedTypeMapAssemblyPath)') ">
      <ResolvedFileToPublish Include="$(_LinkedTypeMapAssemblyPath)" />
    </ItemGroup>
    <!-- Create empty .jlo.xml and .typemap.xml files for the TypeMaps assembly so GenerateJavaStubs doesn't fail -->
    <WriteLinesToFile Condition=" Exists('$(_LinkedTypeMapAssemblyPath)') and !Exists('$(_LinkedTypeMapJloXmlPath)') "
                      File="$(_LinkedTypeMapJloXmlPath)"
                      Lines="&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;api /&gt;"
                      Overwrite="true" />
    <WriteLinesToFile Condition=" Exists('$(_LinkedTypeMapAssemblyPath)') and !Exists('$(_LinkedTypeMapTypemapXmlPath)') "
                      File="$(_LinkedTypeMapTypemapXmlPath)"
                      Lines=""
                      Overwrite="true" />
    <Warning Condition=" !Exists('$(_LinkedTypeMapAssemblyPath)') " 
             Text="TypeMaps assembly not found in linked output: $(_LinkedTypeMapAssemblyPath)" />
  </Target>

  <!-- Generate proguard keep rules based on the types that survived IL trimming.
       This ensures R8 only keeps Java classes that are actually used by the app.
       Runs after ILLink, before _CompileToDalvik which invokes R8. -->
  <Target Name="_GenerateProguardFromTypeMap"
      AfterTargets="_AddLinkedTypeMapAssemblyToPublish"
      BeforeTargets="_CalculateProguardConfigurationFiles"
      Condition=" '$(PublishTrimmed)' == 'true' and '$(AndroidUseTrimmableTypeMap)' == 'true' and '$(AndroidLinkTool)' != '' ">
    <PropertyGroup>
      <!-- Compute the linked TypeMaps assembly path (same logic as _AddLinkedTypeMapAssemblyToPublish) -->
      <_TypeMapAssemblyFileName>_Microsoft.Android.TypeMaps.dll</_TypeMapAssemblyFileName>
      <_LinkedTypeMapAssemblyPath>$(IntermediateLinkDir)$(_TypeMapAssemblyFileName)</_LinkedTypeMapAssemblyPath>
      <_TypeMapProguardConfig>$(IntermediateOutputPath)proguard\proguard_typemap.cfg</_TypeMapProguardConfig>
    </PropertyGroup>
    <GenerateProguardFromTypeMap
        Condition=" Exists('$(_LinkedTypeMapAssemblyPath)') "
        TypeMapsAssembly="$(_LinkedTypeMapAssemblyPath)"
        OutputProguardConfiguration="$(_TypeMapProguardConfig)"
        Enabled="true" />
    <!-- Add to proguard configuration files -->
    <ItemGroup Condition=" Exists('$(_TypeMapProguardConfig)') ">
      <ProguardConfiguration Include="$(_TypeMapProguardConfig)" />
    </ItemGroup>
  </Target>

  <!-- Collect LLVM IR files generated by GenerateTypeMapAssembly for Type Mapping API marshal methods -->
  <Target Name="_CollectTypeMapMarshalMethodSources" 
          BeforeTargets="_CompileNativeAssemblySources"
          Condition=" '$(AndroidUseTrimmableTypeMap)' == 'true' ">
    <Warning Text="[COLLECT DEBUG] Running _CollectTypeMapMarshalMethodSources" />
    <PropertyGroup>
      <!-- Use IntermediateOutputPath (RID-specific) to match where _GenerateTypeMapAssembly writes files -->
      <_AndroidMarshalMethodsDir>$(IntermediateOutputPath)android</_AndroidMarshalMethodsDir>
    </PropertyGroup>
    <Message Importance="high" Text="[COLLECT] _AndroidMarshalMethodsDir=$(_AndroidMarshalMethodsDir)" />
    <Message Importance="high" Text="[COLLECT] _AndroidRuntime=$(_AndroidRuntime), _BuildTargetAbis=@(_BuildTargetAbis)" />
    <!-- Collect the raw .ll files first (no ABI metadata yet) -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSourceRaw Include="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_*.ll" />
      <!-- Ensure the legacy obj is not passed to native compilation -->
      <AndroidNativeLibrary Remove="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.o" />
      <AndroidNativeSource Remove="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.ll" />
    </ItemGroup>
    <Message Importance="high" Text="[COLLECT] Found @(_TypeMapMarshalMethodsSourceRaw->Count()) TypeMap marshal method source files" />
    <!-- Batch the files for each target ABI (LLVM IR is architecture-independent, compiled per-ABI) -->
    <ItemGroup>
      <_TypeMapMarshalMethodsSource Include="@(_TypeMapMarshalMethodsSourceRaw)">
        <abi>%(_BuildTargetAbis.Identity)</abi>
      </_TypeMapMarshalMethodsSource>
    </ItemGroup>
    <!--
    <ItemGroup>
      <_MarshalMethodsAssemblySource Include="@(_TypeMapMarshalMethodsSource)" />
    </ItemGroup>
    <Warning Text="[COLLECT DEBUG] Added @(_TypeMapMarshalMethodsSource->Count()) files to _MarshalMethodsAssemblySource" />
    -->
    <Message Importance="high" Text="[COLLECT] Total @(_TypeMapMarshalMethodsSource->Count()) TypeMap marshal method sources (after ABI batching)" />
  </Target>

  <Target Name="_RemoveLegacyTypemapMarshalMethods"
          BeforeTargets="_CompileNativeAssemblySources"
          Condition=" '$(_AndroidRuntime)' != 'MonoVM' ">
    <PropertyGroup>
      <_TypeMapBaseOutputDir>$(BaseIntermediateOutputPath)$(Configuration)\$(TargetFramework)\</_TypeMapBaseOutputDir>
      <_AndroidMarshalMethodsDir>$([System.IO.Path]::Combine('$(_TypeMapBaseOutputDir)', 'android'))</_AndroidMarshalMethodsDir>
    </PropertyGroup>
    <ItemGroup>
      <AndroidNativeSource Remove="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.ll" />
      <AndroidNativeLibrary Remove="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.o" />
    </ItemGroup>
    <Delete Files="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.ll" ContinueOnError="true" />
    <Delete Files="$(_AndroidMarshalMethodsDir)$([System.IO.Path]::DirectorySeparatorChar)marshal_methods_typemap.o" ContinueOnError="true" />
  </Target>

</Project>
