#nullable enable
using System.Collections.Concurrent;
using Microsoft.Android.Build.Tasks;
using Microsoft.Build.Framework;
using Xamarin.Android.Tools;

namespace Xamarin.Android.Tasks;

public class RewriteMarshalMethods : AndroidTask
{
	public override string TaskPrefix => "RMM";

	public bool EnableManagedMarshalMethodsLookup { get; set; }

	public ITaskItem [] Environments { get; set; } = [];

	[Required]
	public string IntermediateOutputDirectory { get; set; } = "";

	public override bool RunTask ()
	{
		// Retrieve the stored NativeCodeGenState
		var nativeCodeGenStates = BuildEngine4.GetRegisteredTaskObjectAssemblyLocal<ConcurrentDictionary<AndroidTargetArch, NativeCodeGenState>> (
			MonoAndroidHelper.GetProjectBuildSpecificTaskObjectKey (GenerateJavaStubs.NativeCodeGenStateRegisterTaskKey, WorkingDirectory, IntermediateOutputDirectory),
			RegisteredTaskObjectLifetime.Build
		);

		// We need to parse the environment files supplied by the user to see if they want to use broken exception transitions. This information is needed
		// in order to properly generate wrapper methods in the marshal methods assembly rewriter.
		// We don't care about those generated by us, since they won't contain the `XA_BROKEN_EXCEPTION_TRANSITIONS` variable we look for.
		var environmentParser = new EnvironmentFilesParser ();
		bool brokenExceptionTransitionsEnabled = environmentParser.AreBrokenExceptionTransitionsEnabled (Environments);

		foreach (var kvp in nativeCodeGenStates) {
			NativeCodeGenState state = kvp.Value;

			if (state.Classifier is null) {
				Log.LogError ("state.Classifier cannot be null if marshal methods are enabled");
				return false;
			}

			if (!EnableManagedMarshalMethodsLookup) {
				RewriteMethods (state, brokenExceptionTransitionsEnabled);
				state.Classifier.AddSpecialCaseMethods ();
			} else {
				// We need to run `AddSpecialCaseMethods` before `RewriteMarshalMethods` so that we can see the special case
				// methods (such as TypeManager.n_Activate_mm) when generating the managed lookup tables.
				state.Classifier.AddSpecialCaseMethods ();
				state.ManagedMarshalMethodsLookupInfo = new ManagedMarshalMethodsLookupInfo (Log);
				RewriteMethods (state, brokenExceptionTransitionsEnabled);
			}

			Log.LogDebugMessage ($"[{state.TargetArch}] Number of generated marshal methods: {state.Classifier.MarshalMethods.Count}");
			if (state.Classifier.RejectedMethodCount > 0) {
				Log.LogWarning ($"[{state.TargetArch}] Number of methods in the project that will be registered dynamically: {state.Classifier.RejectedMethodCount}");
			}

			if (state.Classifier.WrappedMethodCount > 0) {
				// TODO: change to LogWarning once the generator can output code which requires no non-blittable wrappers
				Log.LogDebugMessage ($"[{state.TargetArch}] Number of methods in the project that need marshal method wrappers: {state.Classifier.WrappedMethodCount}");
			}
		}

		return !Log.HasLoggedErrors;
	}

	void RewriteMethods (NativeCodeGenState state, bool brokenExceptionTransitionsEnabled)
	{
		if (state.Classifier == null) {
			return;
		}

		var rewriter = new MarshalMethodsAssemblyRewriter (Log, state.TargetArch, state.Classifier, state.Resolver, state.ManagedMarshalMethodsLookupInfo);
		rewriter.Rewrite (brokenExceptionTransitionsEnabled);
	}
}
