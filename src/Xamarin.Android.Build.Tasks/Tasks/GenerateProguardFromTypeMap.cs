#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.Build.Framework;
using Microsoft.Android.Build.Tasks;
using Mono.Cecil;

namespace Xamarin.Android.Tasks
{
	/// <summary>
	/// Generates R8/ProGuard keep rules based on the types present in the linked
	/// _Microsoft.Android.TypeMaps.dll assembly.
	/// 
	/// This task runs AFTER IL trimming, so it only generates keep rules for types
	/// that survived trimming - ensuring the Java DEX only contains classes that
	/// are actually used by the app.
	/// </summary>
	public class GenerateProguardFromTypeMap : AndroidTask
	{
		public override string TaskPrefix => "GPFTM";

		/// <summary>
		/// Path to the linked _Microsoft.Android.TypeMaps.dll assembly.
		/// </summary>
		[Required]
		public string TypeMapsAssembly { get; set; } = "";

		/// <summary>
		/// Output path for the generated proguard configuration file.
		/// </summary>
		[Required]
		public string OutputProguardConfiguration { get; set; } = "";

		/// <summary>
		/// Whether to enable this task. When false, no proguard rules are generated.
		/// </summary>
		public bool Enabled { get; set; } = true;

		public override bool RunTask ()
		{
			if (!Enabled) {
				Log.LogDebugMessage ($"[{TaskPrefix}] Task disabled, skipping proguard generation");
				return true;
			}

			if (!File.Exists (TypeMapsAssembly)) {
				Log.LogDebugMessage ($"[{TaskPrefix}] TypeMaps assembly not found: {TypeMapsAssembly}");
				return true;
			}

			var outputDir = Path.GetDirectoryName (OutputProguardConfiguration);
			if (!string.IsNullOrEmpty (outputDir) && !Directory.Exists (outputDir)) {
				Directory.CreateDirectory (outputDir);
			}

			var javaTypes = CollectJavaTypesFromTypeMap ();
			WriteProguardConfiguration (javaTypes);

			Log.LogDebugMessage ($"[{TaskPrefix}] Generated proguard rules for {javaTypes.Count} types");
			return !Log.HasLoggedErrors;
		}

		List<string> CollectJavaTypesFromTypeMap ()
		{
			var javaTypes = new List<string> ();

			using var resolver = new DefaultAssemblyResolver ();
			resolver.AddSearchDirectory (Path.GetDirectoryName (TypeMapsAssembly));

			var readerParams = new ReaderParameters {
				AssemblyResolver = resolver,
				ReadSymbols = false,
				ReadWrite = false,
			};

			using var assembly = AssemblyDefinition.ReadAssembly (TypeMapsAssembly, readerParams);

			// TypeMapAttribute is applied at assembly level, not type level
			// Look for: [assembly: TypeMapAttribute<T>(jniName, proxyType, ...)]
			foreach (var attr in assembly.CustomAttributes) {
				if (!attr.AttributeType.Name.StartsWith ("TypeMapAttribute", StringComparison.Ordinal))
					continue;

				// First constructor argument is the JNI name (string)
				if (attr.ConstructorArguments.Count > 0) {
					var javaName = attr.ConstructorArguments[0].Value?.ToString ();
					if (!javaName.IsNullOrEmpty ()) {
						// Convert from JNI format (com/example/MyClass) to Java format (com.example.MyClass)
						var javaClassName = javaName.Replace ('/', '.');
						javaTypes.Add (javaClassName);
						Log.LogDebugMessage ($"[{TaskPrefix}] Found TypeMap: {javaClassName}");
					}
				}
			}

			return javaTypes;
		}

		void WriteProguardConfiguration (List<string> javaTypes)
		{
			using var writer = File.CreateText (OutputProguardConfiguration);

			writer.WriteLine ("# Auto-generated proguard rules from TypeMap");
			writer.WriteLine ("# This file contains keep rules for Java types that survived IL trimming.");
			writer.WriteLine ("# Generated by GenerateProguardFromTypeMap task.");
			writer.WriteLine ();

			// Write keep rules for each Java type
			foreach (var javaType in javaTypes.Distinct ().OrderBy (t => t)) {
				// Skip Android framework types - they're in android.jar, not our DEX
				if (javaType.StartsWith ("android.", StringComparison.Ordinal) ||
				    javaType.StartsWith ("java.", StringComparison.Ordinal) ||
				    javaType.StartsWith ("javax.", StringComparison.Ordinal) ||
				    javaType.StartsWith ("dalvik.", StringComparison.Ordinal)) {
					continue;
				}

				writer.WriteLine ($"-keep class {javaType} {{ *; }}");
			}

			writer.WriteLine ();
			writer.WriteLine ("# End of auto-generated rules");
		}
	}
}
