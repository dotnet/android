using Microsoft.Build.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Xamarin.Android.Tools;
using Xamarin.Build;

namespace Xamarin.Android.Tasks
{
	/// <summary>
	/// We used to invoke aapt/aapt2 per library (many times!), this task does the work to generate R.java for libraries without calling aapt/aapt2.
	/// </summary>
	public class GenerateLibraryResources : AsyncTask
	{
		/// <summary>
		/// The main R.txt for the app
		/// </summary>
		[Required]
		public string ResourceSymbolsTextFile { get; set; }

		/// <summary>
		/// The output directory for Java source code, such as: $(IntermediateOutputPath)android\src
		/// </summary>
		[Required]
		public string OutputDirectory { get; set; }

		/// <summary>
		/// The list of R.txt files for each library
		/// </summary>
		public string [] LibraryTextFiles { get; set; }

		/// <summary>
		/// The accompanying manifest file for each library
		/// </summary>
		public string [] ManifestFiles { get; set; }

		public override bool Execute ()
		{
			Yield ();
			try {
				this.RunTask (DoExecute).ContinueWith (Complete);

				base.Execute ();
			} finally {
				Reacquire ();
			}

			return !Log.HasLoggedErrors;
		}

		string main_r_txt;
		string output_directory;
		Dictionary<string, string> r_txt_mapping;

		void DoExecute ()
		{
			if (LibraryTextFiles == null || LibraryTextFiles.Length == 0)
				return;

			// Load the "main" R.txt file into a dictionary
			main_r_txt = Path.GetFullPath (ResourceSymbolsTextFile);
			r_txt_mapping = new Dictionary<string, string> ();
			using (var reader = File.OpenText (main_r_txt)) {
				foreach (var line in ParseFile (reader)) {
					var key = line [Index.Class] + " " + line [Index.Name];
					r_txt_mapping [key] = line [Index.Value];
				}
			}

			Directory.CreateDirectory (OutputDirectory);
			output_directory = Path.GetFullPath (OutputDirectory);

			var libraries = LibraryTextFiles.Zip (ManifestFiles, (textFile, manifestFile) => new Library (textFile, manifestFile));
			this.ParallelForEach (libraries, GenerateJava);
		}

		/// <summary>
		/// A quick class to combine the paths to R.txt and Manifest
		/// </summary>
		class Library
		{
			public Library (string textFile, string manifestFile)
			{
				TextFile = Path.GetFullPath (textFile);
				ManifestFile = Path.GetFullPath (manifestFile);
			}

			/// <summary>
			/// A full path to the R.txt file
			/// </summary>
			public string TextFile { get; }

			/// <summary>
			/// A full path to the AndroidManifest.xml file
			/// </summary>
			public string ManifestFile { get; }
		}

		/// <summary>
		/// NOTE: all file paths used in this method should be full paths. (Or use AsyncTask.WorkingDirectory)
		/// </summary>
		void GenerateJava (Library library)
		{
			// In some cases (such as ancient support libraries), R.txt does not exist.
			// We can just use the main app's R.txt file and write *all fields* in this case.
			bool using_main_r_txt = false;
			var r_txt = library.TextFile;
			if (!File.Exists (r_txt)) {
				LogDebugMessage ($"Using main R.txt, R.txt does not exist: {r_txt}");
				using_main_r_txt = true;
				r_txt = main_r_txt;
			}

			var manifestFile = library.ManifestFile;
			if (!File.Exists (manifestFile)) {
				LogDebugMessage ($"Skipping, AndroidManifest.xml does not exist: {manifestFile}");
				return;
			}

			var manifest = AndroidAppManifest.Load (manifestFile, MonoAndroidHelper.SupportedVersions);

			using (var memory = new MemoryStream ())
			using (var writer = new StreamWriter (memory, Encoding)) {
				// This code is based on the Android gradle plugin
				// https://android.googlesource.com/platform/tools/base/+/908b391a9c006af569dfaff08b37f8fdd6c4da89/build-system/builder/src/main/java/com/android/builder/internal/SymbolWriter.java

				writer.WriteLine ("/* AUTO-GENERATED FILE. DO NOT MODIFY.");
				writer.WriteLine (" *");
				writer.WriteLine (" * This class was automatically generated by");
				writer.WriteLine (" * Xamarin.Android from the resource data it found.");
				writer.WriteLine (" * It should not be modified by hand.");
				writer.WriteLine (" */");

				writer.Write ("package ");
				writer.Write (manifest.PackageName);
				writer.WriteLine (';');
				writer.WriteLine ();
				writer.WriteLine ("public final class R {");

				using (var reader = File.OpenText (r_txt)) {
					string currentClass = null;
					foreach (var line in ParseFile (reader)) {
						var type  = line [Index.Type];
						var clazz = line [Index.Class];
						var name  = line [Index.Name];
						if (GetValue (clazz, name, line, using_main_r_txt, out string value)) {
							if (clazz != currentClass) {
								// If not the first inner class
								if (currentClass != null) {
									writer.WriteLine ("\t}");
								}

								currentClass = clazz;
								writer.Write ("\tpublic static final class ");
								writer.Write (currentClass);
								writer.WriteLine (" {");
							}

							writer.Write ("\t\tpublic static final ");
							writer.Write (type);
							writer.Write (' ');
							writer.Write (name);
							writer.Write (" = ");
							// It may be an int[]
							if (value.StartsWith ("{", StringComparison.Ordinal)) {
								writer.Write ("new ");
								writer.Write (type);
								writer.Write (' ');
							}
							writer.Write (value);
							writer.WriteLine (';');
						} else {
							LogDebugMessage ($"{r_txt}: `{type} {clazz} {name}` value not found");
						}
					}

					// If we wrote at least one inner class
					if (currentClass != null) {
						writer.WriteLine ("\t}");
					}
					writer.WriteLine ('}');
				}

				writer.Flush ();
				var r_java = Path.Combine (output_directory, manifest.PackageName.Replace ('.', Path.DirectorySeparatorChar), "R.java");
				if (MonoAndroidHelper.CopyIfStreamChanged (memory, r_java)) {
					LogDebugMessage ($"Writing: {r_java}");
				} else {
					LogDebugMessage ($"Up to date: {r_java}");
				}
			}
		}

		bool GetValue (string clazz, string name, string[] line, bool using_main_r_txt, out string value)
		{
			// If this is the main R.txt file, we don't need to do a lookup
			if (using_main_r_txt) {
				value = line [Index.Value];
				return true;
			}

			var key = clazz + " " + name;
			return r_txt_mapping.TryGetValue (key, out value);
		}

		static readonly Encoding Encoding = new UTF8Encoding (encoderShouldEmitUTF8Identifier: false);
		static readonly char [] Delimiter = new [] { ' ' };

		class Index
		{
			public const int Type  = 0;
			public const int Class = 1;
			public const int Name  = 2;
			public const int Value = 3;
		}

		/// <summary>
		/// R.txt is of the format:
		///    int id icon 0x7f0c000a
		///    int[] styleable ViewStubCompat { 0x010100d0, 0x010100f2, 0x010100f3 }
		/// This returns a 4-length string[] of the parts.
		/// </summary>
		IEnumerable<string []> ParseFile (StreamReader reader)
		{
			while (!reader.EndOfStream) {
				var line = reader.ReadLine ();
				var items = line.Split (Delimiter, 4);
				yield return items;
			}
		}
	}
}
