using Microsoft.Build.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Xamarin.Android.Tools;
using Xamarin.Build;

namespace Xamarin.Android.Tasks
{
	/// <summary>
	/// We used to invoke aapt/aapt2 per library (many times!), this task does the work to generate R.java for libraries without calling aapt/aapt2.
	/// </summary>
	public class GenerateLibraryResources : AndroidAsyncTask
	{
		public override string TaskPrefix => "GLR";

		/// <summary>
		/// The main R.txt for the app
		/// </summary>
		[Required]
		public string ResourceSymbolsTextFile { get; set; }

		/// <summary>
		/// The output directory for Java source code, such as: $(IntermediateOutputPath)android\src
		/// </summary>
		[Required]
		public string OutputDirectory { get; set; }

		/// <summary>
		/// The list of R.txt files for each library
		/// </summary>
		public string [] LibraryTextFiles { get; set; }

		/// <summary>
		/// The accompanying manifest file for each library
		/// </summary>
		public string [] ManifestFiles { get; set; }

		string main_r_txt;
		string output_directory;
		Dictionary<string, string> r_txt_mapping;

		public async override System.Threading.Tasks.Task RunTaskAsync ()
		{
			if (LibraryTextFiles == null || LibraryTextFiles.Length == 0)
				return;

			// Load the "main" R.txt file into a dictionary
			main_r_txt = Path.GetFullPath (ResourceSymbolsTextFile);
			r_txt_mapping = new Dictionary<string, string> ();
			using (var reader = File.OpenText (main_r_txt)) {
				foreach (var line in ParseFile (reader)) {
					var key = line [Index.Class] + " " + line [Index.Name];
					r_txt_mapping [key] = line [Index.Value];
				}
			}

			Directory.CreateDirectory (OutputDirectory);
			output_directory = Path.GetFullPath (OutputDirectory);

			var libraries = new Dictionary<string, Package> ();
			for (int i = 0; i < LibraryTextFiles.Length; i++) {
				var libraryTextFile = LibraryTextFiles [i];
				var manifestFile = ManifestFiles [i];
				if (!File.Exists (manifestFile)) {
					LogDebugMessage ($"Skipping, AndroidManifest.xml does not exist: {manifestFile}");
					continue;
				}

				var manifest = AndroidAppManifest.Load (Path.GetFullPath (manifestFile), MonoAndroidHelper.SupportedVersions);
				var packageName = manifest.PackageName;
				if (!libraries.TryGetValue (packageName, out Package library)) {
					libraries.Add (packageName, library = new Package {
						Name = packageName,
					});
				}
				library.TextFiles.Add (Path.GetFullPath (libraryTextFile));
			}
			await this.WhenAll (libraries.Values, GenerateJava);
		}

		/// <summary>
		/// A class that represents the input to generate an `R.java` file for a given package
		/// </summary>
		class Package
		{
			/// <summary>
			/// A list of full paths to R.txt files
			/// </summary>
			public List<string> TextFiles { get; private set; } = new List<string> (1); // Usually one item

			/// <summary>
			/// The package name found in the AndroidManifest.xml file
			/// </summary>
			public string Name { get; set; }
		}

		/// <summary>
		/// NOTE: all file paths used in this method should be full paths. (Or use AsyncTask.WorkingDirectory)
		/// </summary>
		void GenerateJava (Package package)
		{
			// In some cases (such as ancient support libraries), R.txt does not exist.
			// We can just use the main app's R.txt file and write *all fields* in this case.
			foreach (var r_txt in package.TextFiles) {
				if (!File.Exists (r_txt)) {
					LogDebugMessage ($"Using main R.txt, R.txt does not exist: {r_txt}");
					package.TextFiles.Clear ();
					package.TextFiles.Add (main_r_txt);
					break;
				}
			}

			var lines = LoadValues (package);
			using (var writer = MemoryStreamPool.Shared.CreateStreamWriter ()) {
				// This code is based on the Android gradle plugin
				// https://android.googlesource.com/platform/tools/base/+/908b391a9c006af569dfaff08b37f8fdd6c4da89/build-system/builder/src/main/java/com/android/builder/internal/SymbolWriter.java

				writer.WriteLine ("/* AUTO-GENERATED FILE. DO NOT MODIFY.");
				writer.WriteLine (" *");
				writer.WriteLine (" * This class was automatically generated by");
				writer.WriteLine (" * Xamarin.Android from the resource data it found.");
				writer.WriteLine (" * It should not be modified by hand.");
				writer.WriteLine (" */");

				writer.Write ("package ");
				writer.Write (package.Name);
				writer.WriteLine (';');
				writer.WriteLine ();
				writer.WriteLine ("public final class R {");

				string currentClass = null;
				foreach (var line in lines) {
					var type  = line [Index.Type];
					var clazz = line [Index.Class];
					var name  = line [Index.Name];
					var value = line [Index.Value];
					if (clazz != currentClass) {
						// If not the first inner class
						if (currentClass != null) {
							writer.WriteLine ("\t}");
						}

						currentClass = clazz;
						writer.Write ("\tpublic static final class ");
						writer.Write (currentClass);
						writer.WriteLine (" {");
					}

					writer.Write ("\t\tpublic static final ");
					writer.Write (type);
					writer.Write (' ');
					writer.Write (name);
					writer.Write (" = ");
					// It may be an int[]
					if (value.StartsWith ("{", StringComparison.Ordinal)) {
						writer.Write ("new ");
						writer.Write (type);
						writer.Write (' ');
					}
					writer.Write (value);
					writer.WriteLine (';');
				}

				// If we wrote at least one inner class
				if (currentClass != null) {
					writer.WriteLine ("\t}");
				}
				writer.WriteLine ('}');

				writer.Flush ();
				var r_java = Path.Combine (output_directory, package.Name.Replace ('.', Path.DirectorySeparatorChar), "R.java");
				if (MonoAndroidHelper.CopyIfStreamChanged (writer.BaseStream, r_java)) {
					LogDebugMessage ($"Writing: {r_java}");
				} else {
					LogDebugMessage ($"Up to date: {r_java}");
				}
			}
		}

		/// <summary>
		/// There can be multiple AndroidManifest.xml with the same package name.
		/// We must merge the combination of the resource IDs to be generated in a "merged" R.java file.
		/// </summary>
		string [][] LoadValues (Package library)
		{
			var dictionary = new Dictionary<string, string []> ();
			foreach (var r_txt in library.TextFiles) {
				using (var reader = File.OpenText (r_txt)) {
					foreach (var line in ParseFile (reader)) {
						var type = line [Index.Type];
						var clazz = line [Index.Class];
						var name = line [Index.Name];
						var key = clazz + " " + name;
						if (!dictionary.ContainsKey (key)) {
							if (SetValue (key, line, r_txt)) {
								dictionary.Add (key, line);
							} else {
								LogDebugMessage ($"{r_txt}: `{type} {clazz} {name}` value not found");
							}
						}
					}
				}
			}
			return dictionary.Values.ToArray ();
		}

		/// <summary>
		/// Sets the actual value from the app's main R.txt file
		/// </summary>
		/// <param name="key">Combination of `clazz + " " + name`</param>
		/// <param name="line">string[] representing a line of the R.txt file</param>
		/// <param name="r_txt">path to the R.txt file on disk</param>
		/// <returns>true if the value was found</returns>
		bool SetValue (string key, string[] line, string r_txt)
		{
			// If this is the main R.txt file, `line` already contains the value
			if (r_txt == main_r_txt) {
				return true;
			}
			if (r_txt_mapping.TryGetValue (key, out string value)) {
				line [Index.Value] = value;
				return true;
			}
			return false;
		}
		static readonly char [] Delimiter = new [] { ' ' };

		class Index
		{
			public const int Type  = 0;
			public const int Class = 1;
			public const int Name  = 2;
			public const int Value = 3;
		}

		/// <summary>
		/// R.txt is of the format:
		///    int id icon 0x7f0c000a
		///    int[] styleable ViewStubCompat { 0x010100d0, 0x010100f2, 0x010100f3 }
		/// This returns a 4-length string[] of the parts.
		/// </summary>
		IEnumerable<string []> ParseFile (StreamReader reader)
		{
			while (!reader.EndOfStream) {
				var line = reader.ReadLine ();
				var items = line.Split (Delimiter, 4);
				yield return items;
			}
		}
	}
}
