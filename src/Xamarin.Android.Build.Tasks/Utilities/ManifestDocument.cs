using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using System.Xml.XPath;
using Microsoft.Build.Utilities;

using Android.App;
using Android.Content;

using Mono.Cecil;
using Mono.Cecil.Cil;

using MonoDroid.Utils;
using Monodroid;

using Java.Interop.Tools.Cecil;
using Java.Interop.Tools.TypeNameMappings;

using System.Xml;
using System.Text;
using Xamarin.Android.Tools;
using Microsoft.Android.Build.Tasks;

namespace Xamarin.Android.Tasks {

	internal class ManifestDocument
	{
		public static XNamespace AndroidXmlNamespace = "http://schemas.android.com/apk/res/android";
		public static XNamespace AndroidXmlToolsNamespace = "http://schemas.android.com/tools";

		const int maxVersionCode = 2100000000;

		static XNamespace androidNs = AndroidXmlNamespace;
		static XNamespace androidToolsNs = AndroidXmlToolsNamespace;
		static readonly XName versionCodeAttributeName = androidNs + "versionCode";

		XDocument doc;

		XName attName;

		XElement app;

		// the elements and attributes which we apply the "." -> PackageName replacement on
		static readonly Dictionary<string, string []> ManifestAttributeFixups = new Dictionary<string, string []> {
			{ "activity", new string[] {
					"name",
				}
			},
			{ "application", new string[] {
					"backupAgent",
				}
			},
			{ "instrumentation", new string[] {
					"name",
				}
			},
			{ "provider", new string[] {
					"name",
				}
			},
			{ "receiver", new string[] {
					"name",
				}
			},
			{ "service", new string[] {
					"name",
				}
			},
		};

		// (element, android:name attribute value) which must ALL be present for
		// the <activity/> to be considered a launcher
		static readonly Dictionary<string, string> LauncherIntentElements = new Dictionary<string, string> {
			{ "action",   "android.intent.action.MAIN" },
			{ "category", "android.intent.category.LAUNCHER" },
		};

		public string PackageName { get; set; }
		public string ApplicationLabel { get; set; }
		public string [] Placeholders { get; set; }
		public List<string> Assemblies { get; set; }
		public IAssemblyResolver Resolver { get; set; }
		public string SdkDir { get; set; }
		public string TargetSdkVersion { get; set; }
		public string MinSdkVersion { get; set; }
		public bool Debug { get; set; }
		public bool MultiDex { get; set; }
		public bool NeedsInternet { get; set; }
		public bool ForceExtractNativeLibs { get; set; }
		public bool ForceDebuggable { get; set; }
		public string VersionName { get; set; }
		public IVersionResolver VersionResolver { get; set; } = new MonoAndroidHelperVersionResolver ();
		public string AndroidRuntime { get; set; } = "MonoVM";

		string versionCode;

		/// <summary>
		/// NOTE: this property modifies the underlying XDocument
		/// </summary>
		public string VersionCode {
			get {
				XAttribute attr = doc.Root.Attribute (versionCodeAttributeName);
				if (attr != null) {
					string code = attr.Value;
					if (!string.IsNullOrEmpty (code))
						return code;
				}
				return "1";
			}
			set {
				doc.Root.SetAttributeValue (versionCodeAttributeName, versionCode = value);
			}
		}

		public bool HasVersionCode => doc.Root.Attribute (versionCodeAttributeName) != null;

		// If MinSdkVersionName can't be parsed, set it to XABuildConfig.AndroidMinimumDotNetApiLevel
		string TryParseMinSdkVersionName ()
		{
			int minSdkVersion;
			if (!int.TryParse (MinSdkVersionName, out minSdkVersion))
				minSdkVersion = XABuildConfig.AndroidMinimumDotNetApiLevel;
			return minSdkVersion.ToString ();
		}

		public string GetMinimumSdk () {
			var minAttr = doc.Root.Element ("uses-sdk")?.Attribute (androidNs + "minSdkVersion");
			if (minAttr == null) {
				return TryParseMinSdkVersionName ();
			}
			return minAttr.Value;
		}

		public string GetTargetSdk ()
		{
			var targetAttr = doc.Root.Element ("uses-sdk")?.Attribute (androidNs + "targetSdkVersion");
			if (targetAttr == null) {
				return TargetSdkVersionName;
			}
			return targetAttr.Value;
		}

		public ManifestDocument (string templateFilename) : base ()
		{
			Assemblies = new List<string> ();

			attName = androidNs + "name";

			if (!string.IsNullOrEmpty (templateFilename)) {
				doc = XDocument.Load (templateFilename, LoadOptions.SetLineInfo);
				InjectAutoGeneratedComment (doc.Root, templateFilename);
				AndroidResource.UpdateXmlResource (doc.Root);
			} else {
				doc = new XDocument (new XElement ("manifest"));
				InjectAutoGeneratedComment (doc.Root);
			}
		}

		string TargetSdkVersionName => VersionResolver.GetIdFromApiLevel (TargetSdkVersion);

		string MinSdkVersionName =>
			string.IsNullOrEmpty (MinSdkVersion) ?
				TargetSdkVersionName :
				VersionResolver.GetIdFromApiLevel (MinSdkVersion);

		string ToFullyQualifiedName (string typeName)
		{
			if (typeName.StartsWith (".", StringComparison.Ordinal))
				return PackageName + typeName;
			if (typeName.Contains ("."))
				return typeName;
			return PackageName + "." + typeName;
		}

		XElement GetActivityWithName (XElement app, string name)
		{
			name = ToFullyQualifiedName (name);
			return app.Elements ("activity").FirstOrDefault (e => ToFullyQualifiedName ((string) e.Attribute (androidNs + "name")) == name);
		}

		void InjectAutoGeneratedComment (XElement root, string templateFilename = "")
		{
			if (root.PreviousNode is XComment)
				return;
			root.AddBeforeSelf (new XComment (string.Format (Xamarin.Android.Tasks.Properties.Resources.XA_Manifest_AutoGenerated_Header, templateFilename)));
		}

		void ReorderElements (XElement app)
		{
			var elements = app.ElementsAfterSelf ("uses-permission");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("permission");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("permissionGroup");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("permissionTree");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("permission-group");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("permission-tree");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("uses-feature");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("uses-library");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
			elements = app.ElementsAfterSelf ("supports-gl-texture");
			foreach (var e in elements) {
				e.Remove ();
				app.AddBeforeSelf (e);
			}
		}

		void ReorderActivityAliases (TaskLoggingHelper log, XElement app)
		{
			var aliases = app.Elements ("activity-alias").ToList ();

			foreach (XElement alias in aliases) {
				XAttribute attr = alias.Attribute (androidNs + "targetActivity");
				if (attr == null)
					continue;
				XElement activity = GetActivityWithName (app, attr.Value);
				if (activity != null) {
					alias.Remove ();
					activity.AddAfterSelf (alias);
				} else {
					log.LogCodedWarning ("XA4228", Properties.Resources.XA4228, attr.Value);
				}
			}
		}

		public IList<string> Merge (TaskLoggingHelper log, TypeDefinitionCache cache, List<TypeDefinition> subclasses, string applicationClass, bool embed, string bundledWearApplicationName, IEnumerable<string> mergedManifestDocuments)
		{
			var manifest = doc.Root;

			if (manifest == null || manifest.Name != "manifest")
				throw new Exception ("Root element must be 'manifest'");

			var manifest_package = (string) manifest.Attribute ("package");
			if (string.IsNullOrEmpty (manifest_package)) {
				if (!string.IsNullOrEmpty (PackageName)) {
					manifest.SetAttributeValue ("package", PackageName);
				}
			} else {
				PackageName = manifest_package;
			}
			if (PackageName.Contains ("${")) {
				// placeholder detected
				PackageName = ReplacePlaceholders (Placeholders, PackageName);
				manifest.SetAttributeValue ("package", PackageName);
			}

			manifest.SetAttributeValue (XNamespace.Xmlns + "android", "http://schemas.android.com/apk/res/android");

			if (manifest.Attribute (versionCodeAttributeName) == null) {
				manifest.SetAttributeValue (versionCodeAttributeName,
					string.IsNullOrEmpty (versionCode) ? "1" : versionCode);
			}
			if (manifest.Attribute (androidNs + "versionName") == null) {
				manifest.SetAttributeValue (androidNs + "versionName",
					string.IsNullOrEmpty (VersionName) ? "1.0" : VersionName);
			}

			app = CreateApplicationElement (manifest, applicationClass, subclasses, cache);

			if (app.Attribute (androidNs + "label") == null && !string.IsNullOrEmpty (ApplicationLabel))
				app.SetAttributeValue (androidNs + "label", ApplicationLabel);

			var existingTypes = new HashSet<string> (
				app.Descendants ().Select (a => (string) a.Attribute (attName)).Where (v => v != null));

			if (!string.IsNullOrEmpty (bundledWearApplicationName)) {
				if (!app.Elements ("meta-data").Any (e => e.Attributes (androidNs + "name").Any (a => a.Value == bundledWearApplicationName)))
					app.Add (new XElement ("meta-data", new XAttribute (androidNs + "name", "com.google.android.wearable.beta.app"), new XAttribute (androidNs + "resource", "@xml/wearable_app_desc")));
			}

			string minSdkVersionString = TryParseMinSdkVersionName ();

			// If no <uses-sdk> is specified, add it with both minSdkVersion and targetSdkVersion
			if (!manifest.Elements ("uses-sdk").Any ()) {
				manifest.AddFirst (
						new XElement ("uses-sdk",
							new XAttribute (androidNs + "minSdkVersion", minSdkVersionString),
							new XAttribute (androidNs + "targetSdkVersion", TargetSdkVersionName)));
			}

			// If no minSdkVersion is specified, set it
			var uses = manifest.Element ("uses-sdk");
			if (uses.Attribute (androidNs + "minSdkVersion") == null) {
				uses.SetAttributeValue (androidNs + "minSdkVersion", minSdkVersionString);
			}

			string targetSdkVersion;
			var tsv = uses.Attribute (androidNs + "targetSdkVersion");
			if (tsv != null)
				targetSdkVersion = tsv.Value;
			else {
				targetSdkVersion = TargetSdkVersionName;
				uses.AddBeforeSelf (new XComment ("suppress UsesMinSdkAttributes"));
			}

			int? tryTargetSdkVersion  = VersionResolver.GetApiLevelFromId (targetSdkVersion);
			if (!tryTargetSdkVersion.HasValue)
				throw new InvalidOperationException (string.Format ("The targetSdkVersion ({0}) is not a valid API level", targetSdkVersion));
			int targetSdkVersionValue = tryTargetSdkVersion.Value;

			foreach (TypeDefinition t in subclasses) {
				if (t.IsAbstract)
					continue;

				if (PackageName == null)
					PackageName = t.Namespace;

				if (t.IsSubclassOf ("Android.App.Application", cache)) {
					(string name, string compatName) = GetNames (t, cache);
					if (((string) app.Attribute (attName)) == compatName) {
						app.SetAttributeValue (attName, name);
					}
					continue;
				}

				Func<TypeDefinition, string, TypeDefinitionCache, int, XElement> generator = GetGenerator (t, cache);
				if (generator == null)
					continue;

				try {
					(string name, string compatName) = GetNames (t, cache);
					// activity not present: create a launcher for it IFF it has attribute
					if (!existingTypes.Contains (name) && !existingTypes.Contains (compatName)) {
						XElement fromCode = generator (t, name, cache, targetSdkVersionValue);
						if (fromCode == null)
							continue;

						IEnumerable <MethodDefinition> constructors = t.Methods.Where (m => m.IsConstructor).Cast<MethodDefinition> ();
						if (!constructors.Any (c => !c.HasParameters && c.IsPublic)) {
							SequencePoint sourceLocation = FindSource (constructors);

							if (sourceLocation != null && sourceLocation.Document?.Url != null) {
								log.LogError (
									subcategory:      String.Empty,
									errorCode:        "XA4213",
									helpKeyword:      String.Empty,
									file:             sourceLocation.Document.Url,
									lineNumber:       sourceLocation.StartLine,
									columnNumber:     sourceLocation.StartColumn,
									endLineNumber:    sourceLocation.EndLine,
									endColumnNumber:  sourceLocation.EndColumn,
									message:          Properties.Resources.XA4213,
									t.FullName);
							} else
								log.LogCodedError ("XA4213", Properties.Resources.XA4213, t.FullName);
							continue;
						}
						app.Add (fromCode);
					}
					foreach (var d in app.Descendants ().Where (a => ((string) a.Attribute (attName)) == compatName)) {
						d.SetAttributeValue (attName, name);
					}
				} catch (InvalidActivityNameException ex) {
					log.LogErrorFromException (ex);
				}
			}

			var icon = app.Attribute (androidNs + "icon");
			if (icon == null) {
				var activity = app.Element ("activity");
				if (activity != null) {
					var activityIcon = activity.Attribute (androidNs + "icon");
					if (activityIcon != null)
						app.Add (new XAttribute (androidNs + "icon", activityIcon.Value));
				}
			}

			PackageName = AndroidAppManifest.CanonicalizePackageName (PackageName);

			if (!PackageName.Contains ('.'))
				throw new InvalidOperationException ("/manifest/@package attribute MUST contain a period ('.').");

			manifest.SetAttributeValue ("package", PackageName);

			if (MultiDex)
				app.Add (CreateMonoRuntimeProvider ("mono.android.MultiDexLoader", null, initOrder: --AppInitOrder));

			var providerNames = AddMonoRuntimeProviders (app);

			bool needDebuggable = false;
			if (Debug) {
				if (app.Attribute (androidNs + "debuggable") == null)
					needDebuggable = true;
			}

			if (ForceDebuggable || needDebuggable) {
				XAttribute debuggable = app.Attribute (androidNs + "debuggable");
				if (debuggable == null)
					app.Add (new XAttribute (androidNs + "debuggable", "true"));
				else
					debuggable.Value = "true";
			}

			if (Debug || NeedsInternet)
				AddInternetPermissionForDebugger ();

			// If the manifest has android:installLocation, but we are targeting
			// API 7 or lower, remove it for the user and show a warning
			if (manifest.Attribute (androidNs + "installLocation") != null) {
				if (targetSdkVersionValue < 8) {
					manifest.Attribute (androidNs + "installLocation").Remove ();
					Console.Error.WriteLine ("monodroid: warning 1 : installLocation cannot be specified for Android versions less than 2.2.  Attribute installLocation ignored.");
				}
			}

			AddInstrumentations (manifest, subclasses, targetSdkVersionValue, cache);
			AddPermissions (app, cache);
			AddPermissionGroups (app, cache);
			AddPermissionTrees (app, cache);
			AddUsesPermissions (app, cache);
			AddUsesFeatures (app, cache);
			AddSupportsGLTextures (app, cache);

			if (targetSdkVersionValue >= 23) {
				if (ForceExtractNativeLibs || app.Attribute (androidNs + "extractNativeLibs") == null)
					app.SetAttributeValue (androidNs + "extractNativeLibs", "true");
			}

			ReorderActivityAliases (log, app);
			ReorderElements (app);

			if (mergedManifestDocuments != null) {
				foreach (var mergedManifest in mergedManifestDocuments) {
					try {
						MergeLibraryManifest (mergedManifest);
					} catch (Exception ex) {
						log.LogCodedWarning ("XA4302", Properties.Resources.XA4302, ex);
					}
				}
			}

			return providerNames;

			SequencePoint FindSource (IEnumerable<MethodDefinition> methods)
			{
				if (methods == null)
					return null;

				SequencePoint ret = null;
				foreach (MethodDefinition method in methods.Where (m => m != null && m.HasBody && m.DebugInformation != null)) {
					foreach (Instruction ins in method.Body.Instructions) {
						SequencePoint seq = method.DebugInformation.GetSequencePoint (ins);
						if (seq == null)
							continue;

						if (ret == null || seq.StartLine < ret.StartLine)
							ret = seq;
						break;
					}
				}

				return ret;
			}
		}

		(string name, string compatName) GetNames(TypeDefinition type, TypeDefinitionCache cache) => (
			JavaNativeTypeManager.ToJniName (type, cache).Replace ('/', '.'),
			JavaNativeTypeManager.ToCompatJniName (type, cache).Replace ('/', '.')
		);

		// FIXME: our manifest merger is hacky.
		// To support complete manifest merger, we will have to implement fairly complicated one, described at
		// http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger
		void MergeLibraryManifest (string mergedManifest)
		{
			var nsResolver = new XmlNamespaceManager (new NameTable ());
			nsResolver.AddNamespace ("android", androidNs.NamespaceName);
			var xdoc = XDocument.Load (mergedManifest);
			var package = xdoc.Root.Attribute ("package")?.Value ?? string.Empty;
			foreach (var top in xdoc.XPathSelectElements ("/manifest/*")) {
				var name = top.Attribute (AndroidXmlNamespace.GetName ("name"));
				var existing = (name != null) ?
					doc.XPathSelectElement (string.Format ("/manifest/{0}[@android:name='{1}']", top.Name.LocalName, name.Value), nsResolver) :
					doc.XPathSelectElement (string.Format ("/manifest/{0}", top.Name.LocalName));
				if (existing != null)
					// if there is existing node with the same android:name, then append contents to existing node.
					existing.Add (FixupNameElements (package, top.Nodes ()));
				else
					// otherwise, just add to the doc.
					doc.Root.Add (FixupNameElements (package, new XNode [] { top }));
			}
		}

		public IEnumerable<XElement> ResolveDuplicates (IEnumerable<XElement> elements)
		{
			foreach (var e in elements)
				foreach (var d in ResolveDuplicates (e.Elements ()))
					yield return d;
			foreach (var d in elements.GroupBy (x => x.ToFullString ()).SelectMany (x => x.Skip (1)))
				yield return d;
		}

		void RemoveDuplicateElements ()
		{
			var duplicates = ResolveDuplicates (doc.Elements ());
			foreach (var duplicate in duplicates)
				duplicate.Remove ();

		}

		void RemoveNodes ()
		{
			var allNodes = doc.Descendants ().ToList ();
			foreach (var node in allNodes) {
				if (!node.HasAttributes)
					continue;
				if (node.Attribute (androidToolsNs + "node")?.Value == "remove") {
					node.Remove ();
				}
			}
		}

		IEnumerable<XNode> FixupNameElements(string packageName, IEnumerable<XNode> nodes)
		{
			foreach (var element in nodes.Select ( x => x as XElement).Where (x => x != null && ManifestAttributeFixups.ContainsKey (x.Name.LocalName))) {
				var attributes = ManifestAttributeFixups [element.Name.LocalName];
				foreach (var attr in element.Attributes ().Where (x => attributes.Contains (x.Name.LocalName))) {
					var typeName = attr.Value;
					attr.Value = typeName.StartsWith (".", StringComparison.InvariantCultureIgnoreCase) ? packageName + typeName : typeName;
				}
			}
			return nodes;
		}

		Func<TypeDefinition, string, TypeDefinitionCache, int, XElement> GetGenerator (TypeDefinition type, TypeDefinitionCache cache)
		{
			if (type.IsSubclassOf ("Android.App.Activity", cache))
				return ActivityFromTypeDefinition;
			if (type.IsSubclassOf ("Android.App.Service", cache))
				return (t, name, c, v) => ToElement (t, name, ServiceAttribute.FromTypeDefinition, x => x.ToElement (PackageName, c), c);
			if (type.IsSubclassOf ("Android.Content.BroadcastReceiver", cache))
				return (t, name, c, v) => ToElement (t, name, BroadcastReceiverAttribute.FromTypeDefinition, x => x.ToElement (PackageName, c), c);
			if (type.IsSubclassOf ("Android.Content.ContentProvider", cache))
				return (t, name, c, v) => ToProviderElement (t, name, c);
			return null;
		}

		XElement CreateApplicationElement (XElement manifest, string applicationClass, List<TypeDefinition> subclasses, TypeDefinitionCache cache)
		{
			var application = manifest.Descendants ("application").FirstOrDefault ();

			List<ApplicationAttribute> assemblyAttr = [];
			List<MetaDataAttribute> metadata = [];
			List<PropertyAttribute> properties = [];
			List<UsesLibraryAttribute> usesLibraryAttr = [];
			List<UsesConfigurationAttribute> usesConfigurationAttr = [];
			foreach (var assemblyPath in Assemblies) {
				var assembly = Resolver.GetAssembly (assemblyPath);
				if (ApplicationAttribute.FromCustomAttributeProvider (assembly, cache) is ApplicationAttribute a) {
					assemblyAttr.Add (a);
				}
				foreach (var m in MetaDataAttribute.FromCustomAttributeProvider (assembly, cache)) {
					if (m is null)
						continue;
					metadata.Add (m);
				}
				foreach (var p in PropertyAttribute.FromCustomAttributeProvider (assembly, cache)) {
					if (p is null)
						continue;
					properties.Add (p);
				}
				foreach (var u in UsesLibraryAttribute.FromCustomAttributeProvider (assembly, cache)) {
					if (u is null)
						continue;
					usesLibraryAttr.Add (u);
				}
				foreach (var uc in UsesConfigurationAttribute.FromCustomAttributeProvider (assembly, cache)) {
					if (uc is null)
						continue;
					usesConfigurationAttr.Add (uc);
				}
			}

			if (assemblyAttr.Count > 1)
				throw new InvalidOperationException ("There can be only one [assembly:Application] attribute defined.");

			List<ApplicationAttribute> typeAttr = [];
			foreach (TypeDefinition t in subclasses) {
				ApplicationAttribute aa = ApplicationAttribute.FromCustomAttributeProvider (t, cache);
				if (aa is null)
					continue;

				if (!t.IsSubclassOf ("Android.App.Application", cache))
					throw new InvalidOperationException (string.Format ("Found [Application] on type {0}.  [Application] can only be used on subclasses of Application.", t.FullName));

				typeAttr.Add (aa);
				metadata.AddRange (MetaDataAttribute.FromCustomAttributeProvider (t, cache));
				properties.AddRange (PropertyAttribute.FromCustomAttributeProvider (t, cache));

				usesLibraryAttr.AddRange (UsesLibraryAttribute.FromCustomAttributeProvider (t, cache));
			}

			if (typeAttr.Count > 1)
				throw new InvalidOperationException ("There can be only one type with an [Application] attribute; found: " +
						string.Join (", ", typeAttr.Select (aa => aa.Name).ToArray ()));

			if (assemblyAttr.Count > 0 && typeAttr.Count > 0)
				throw new InvalidOperationException ("Application cannot have both a type with an [Application] attribute and an [assembly:Application] attribute.");

			ApplicationAttribute appAttr = assemblyAttr.SingleOrDefault () ?? typeAttr.SingleOrDefault ();
			bool needManifestAdd = true;

			if (appAttr != null) {
				var newapp = appAttr.ToElement (Resolver, PackageName, cache);
				if (application == null)
					application = newapp;
				else {
					needManifestAdd = false;
					foreach (var n in newapp.Attributes ())
						application.SetAttributeValue (n.Name, n.Value);
					foreach (var n in newapp.Nodes ())
						application.Add (n);
				}
			}
			else if (application == null)
				application = new XElement ("application");
			else
				needManifestAdd = false;
			foreach (var m in metadata) {
				application.Add (m.ToElement (PackageName, cache));
			}
			foreach (var p in properties) {
				application.Add (p.ToElement (PackageName, cache));
			}

			if (needManifestAdd)
				manifest.Add (application);

			AddUsesLibraries (application, usesLibraryAttr, cache);
			AddUsesConfigurations (application, usesConfigurationAttr, cache);

			if (applicationClass != null && application.Attribute (androidNs + "name") == null)
				application.Add (new XAttribute (androidNs + "name", applicationClass));

			if (application.Attribute (androidNs + "allowBackup") == null)
				application.Add (new XAttribute (androidNs + "allowBackup", "true"));

			return application;
		}

		IList<string> AddMonoRuntimeProviders (XElement app)
		{
			if (!string.Equals (AndroidRuntime, "MonoVM", StringComparison.OrdinalIgnoreCase)) {
				//TODO: implement provider logic for non-Mono runtimes
				return [];
			}

			app.Add (CreateMonoRuntimeProvider ("mono.MonoRuntimeProvider", null, --AppInitOrder));

			var providerNames = new List<string> ();

			var processAttrName = androidNs.GetName ("process");
			var procs = new List<string> ();
			foreach (XElement el in app.Elements ()) {
				var proc = el.Attribute (processAttrName);
				if (proc == null)
					continue;
				if (procs.Contains (proc.Value))
					continue;
				procs.Add (proc.Value);
				if (el.Name.NamespaceName != String.Empty)
					continue;
				switch (el.Name.LocalName) {
				case "provider":
					var autho = el.Attribute (androidNs.GetName ("authorities"));
					if (autho != null && autho.Value.EndsWith (".__mono_init__", StringComparison.Ordinal))
						continue;
					goto case "activity";
				case "activity":
				case "receiver":
				case "service":
					string providerName = "MonoRuntimeProvider_" + procs.Count;
					providerNames.Add (providerName);
					app.Add (CreateMonoRuntimeProvider ("mono." + providerName, proc.Value, --AppInitOrder));
					break;
				}
			}

			return providerNames;
		}

		int AppInitOrder = 2000000000;

		XElement CreateMonoRuntimeProvider (string name, string processName, int initOrder)
		{
			var directBootAware = DirectBootAware ();
			return new XElement ("provider",
						new XAttribute (androidNs + "name", name),
						new XAttribute (androidNs + "exported", "false"),
						new XAttribute (androidNs + "initOrder", initOrder),
						directBootAware ? new XAttribute (androidNs + "directBootAware", "true") : null,
						processName == null ? null : new XAttribute (androidNs + "process", processName),
						new XAttribute (androidNs + "authorities", PackageName + "." + name + ".__mono_init__"));
		}

		bool IsMainLauncher (XElement intentFilter)
		{
			return LauncherIntentElements.All (entry =>
					intentFilter.Elements (entry.Key).Any (e => ((string) e.Attribute (attName) == entry.Value)));
		}

		/// <summary>
		/// Returns true if an element has the @android:directBootAware attribute and its 'true'
		/// </summary>
		public bool DirectBootAware ()
		{
			var processAttrName = androidNs.GetName ("directBootAware");
			var appAttr = app.Attribute (processAttrName);
			bool value;
			if (appAttr != null && bool.TryParse (appAttr.Value, out value) && value)
				return true;
			foreach (XElement el in app.Elements ()) {
				var elAttr = el.Attribute (processAttrName);
				if (elAttr != null && bool.TryParse (elAttr.Value, out value) && value)
					return true;
			}

			// If android:directBootAware is omitted, returns false.
			return false;
		}

		XElement ActivityFromTypeDefinition (TypeDefinition type, string name, TypeDefinitionCache cache, int targetSdkVersion)
		{
			if (name.StartsWith ("_", StringComparison.Ordinal))
				throw new InvalidActivityNameException (string.Format ("Activity name '{0}' is invalid, because activity namespaces may not begin with an underscore.", type.FullName));

			return ToElement (type, name,
					ActivityAttribute.FromTypeDefinition,
					aa => aa.ToElement (Resolver, PackageName, cache, targetSdkVersion),
					(aa, element) => {
						if (aa.MainLauncher)
							AddLauncherIntentElements (element);
						var la = LayoutAttribute.FromTypeDefinition (type, cache);
						if (la != null)
							element.Add (la.ToElement (Resolver, PackageName, cache));
					},
					cache);
		}

		XElement InstrumentationFromTypeDefinition (TypeDefinition type, string name, TypeDefinitionCache cache)
		{
			return ToElement (type, name,
					(t, c) => InstrumentationAttribute.FromCustomAttributeProvider (t, c).FirstOrDefault (),
					ia => {
						if (ia.TargetPackage == null)
							ia.SetTargetPackage (PackageName);
						return ia.ToElement (PackageName, cache);
					},
					cache);
		}

		XElement ToElement<TAttribute> (TypeDefinition type, string name, Func<TypeDefinition, TypeDefinitionCache, TAttribute> parser, Func<TAttribute, XElement> toElement, TypeDefinitionCache cache)
			where TAttribute : class
		{
			return ToElement (type, name, parser, toElement, update: null, cache);
		}

		XElement ToElement<TAttribute> (TypeDefinition type, string name, Func<TypeDefinition, TypeDefinitionCache, TAttribute> parser, Func<TAttribute, XElement> toElement, Action<TAttribute, XElement> update, TypeDefinitionCache cache)
			where TAttribute : class
		{
			TAttribute attr = parser (type, cache);
			if (attr == null)
				return null;

			XElement element = toElement (attr);
			if (element.Attribute (attName) == null)
				element.Add (new XAttribute (attName, name));
			foreach (var m in MetaDataAttribute.FromCustomAttributeProvider (type, cache)) {
				element.Add (m.ToElement (PackageName, cache));
			}
			foreach (var i in IntentFilterAttribute.FromTypeDefinition (type, cache)) {
				element.Add (i.ToElement (PackageName));
			}
			foreach (var p in PropertyAttribute.FromCustomAttributeProvider (type, cache)) {
				element.Add (p.ToElement (PackageName, cache));
			}
			if (update != null)
				update (attr, element);
			return element;
		}

		XElement ToProviderElement (TypeDefinition type, string name, TypeDefinitionCache cache)
		{
			var attr = ContentProviderAttribute.FromTypeDefinition (type, cache);
			if (attr == null)
				return null;

			XElement element = attr.ToElement (PackageName, cache);
			if (element.Attribute (attName) == null)
				element.Add (new XAttribute (attName, name));
			foreach (var m in MetaDataAttribute.FromCustomAttributeProvider (type, cache)) {
				element.Add (m.ToElement (PackageName, cache));
			}
			foreach (var g in GrantUriPermissionAttribute.FromTypeDefinition (type, cache)) {
				element.Add (g.ToElement (PackageName, cache));
			}
			foreach (var i in IntentFilterAttribute.FromTypeDefinition (type, cache)) {
				element.Add (i.ToElement (PackageName));
			}
			foreach (var p in PropertyAttribute.FromCustomAttributeProvider (type, cache)) {
				element.Add (p.ToElement (PackageName, cache));
			}

			return element;
		}

		void AddLauncherIntentElements (XElement activity)
		{
			if (activity.Elements ("intent-filter").Any (f => IsMainLauncher (f)))
				return;

			var filter = new XElement ("intent-filter");

			// Add android:exported="true" if not already present
			XName exported = androidNs + "exported";
			if (activity.Attribute (exported) == null) {
				activity.Add (new XAttribute (exported, "true"));
			}

			activity.AddFirst (filter);
			foreach (KeyValuePair<string, string> e in LauncherIntentElements) {
				if (!filter.Elements (e.Key).Any (x => ((string) x.Attribute (attName)) == e.Value))
					filter.Add (new XElement (e.Key, new XAttribute (attName, e.Value)));
			}
		}

		public void AddInternetPermissionForDebugger ()
		{
			const string permInternet ="android.permission.INTERNET";
			if (!doc.Root.Descendants ("uses-permission").Any (x => (string)x.Attribute (attName) == permInternet))
				app.AddBeforeSelf (new XElement ("uses-permission", new XAttribute (attName, permInternet)));
		}

		void AddPermissions (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => PermissionAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));
			// Add unique permissions to the manifest
			foreach (var pa in assemblyAttrs.Distinct (new PermissionAttribute.PermissionAttributeComparer ()))
				if (!application.Parent.Descendants ("permission").Any (x => (string)x.Attribute (attName) == pa.Name))
					application.AddBeforeSelf (pa.ToElement (PackageName, cache));
		}

		void AddPermissionGroups (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => PermissionGroupAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add unique permissionGroups to the manifest
			foreach (var pga in assemblyAttrs.Distinct (new PermissionGroupAttribute.PermissionGroupAttributeComparer ()))
				if (!application.Parent.Descendants ("permissionGroup").Any (x => (string)x.Attribute (attName) == pga.Name))
					application.AddBeforeSelf (pga.ToElement (PackageName, cache));
		}

		void AddPermissionTrees (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => PermissionTreeAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add unique permissionGroups to the manifest
			foreach (var pta in assemblyAttrs.Distinct (new PermissionTreeAttribute.PermissionTreeAttributeComparer ()))
				if (!application.Parent.Descendants ("permissionTree").Any (x => (string)x.Attribute (attName) == pta.Name))
					application.AddBeforeSelf (pta.ToElement (PackageName, cache));
		}

		void AddUsesPermissions (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => UsesPermissionAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add unique permissions to the manifest
			foreach (var upa in assemblyAttrs.Distinct (new UsesPermissionAttribute.UsesPermissionComparer ()))
				if (!application.Parent.Descendants ("uses-permission").Any (x => (string)x.Attribute (attName) == upa.Name))
					application.AddBeforeSelf (upa.ToElement (PackageName, cache));
		}
		void AddUsesConfigurations (XElement application, List<UsesConfigurationAttribute> configs, TypeDefinitionCache cache)
		{
			foreach (var uca in configs)
				application.Add (uca.ToElement (PackageName, cache));
		}

		void AddUsesLibraries (XElement application, List<UsesLibraryAttribute> libraries, TypeDefinitionCache cache)
		{
			// Add unique libraries to the manifest
			foreach (var ula in libraries)
				if (!application.Descendants ("uses-library").Any (x => (string)x.Attribute (attName) == ula.Name))
					application.Add (ula.ToElement (PackageName, cache));
		}

		void AddUsesFeatures (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => UsesFeatureAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add unique features by Name or glESVersion to the manifest
			foreach (var feature in assemblyAttrs) {
				if (!string.IsNullOrEmpty(feature.Name) && feature.GLESVersion == 0) {
					if (!application.Parent.Descendants ("uses-feature").Any (x => (string)x.Attribute (attName) == feature.Name)) {
						application.AddBeforeSelf (feature.ToElement (PackageName, cache));
					}
				}
				if (feature.GLESVersion != 0){
					if (!application.Parent.Descendants ("uses-feature").Any (x => (string)x.Attribute (androidNs+"glEsVersion") == feature.GLESVesionAsString())) {
						application.AddBeforeSelf (feature.ToElement (PackageName, cache));
					}
				}

			}
		}

		void AddSupportsGLTextures (XElement application, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => SupportsGLTextureAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add unique items by Name to the manifest
			foreach (var feature in assemblyAttrs) {
				if (!application.Parent.Descendants ("supports-gl-texture").Any (x => (string)x.Attribute (attName) == feature.Name)) {
					application.AddBeforeSelf (feature.ToElement (PackageName, cache));
				}
			}
		}

		void AddInstrumentations (XElement manifest, IList<TypeDefinition> subclasses, int targetSdkVersion, TypeDefinitionCache cache)
		{
			var assemblyAttrs =
				Assemblies.SelectMany (path => InstrumentationAttribute.FromCustomAttributeProvider (Resolver.GetAssembly (path), cache));

			// Add instrumentation to the manifest
			foreach (var ia in assemblyAttrs) {
				if (ia.TargetPackage == null)
					ia.SetTargetPackage (PackageName);
				if (!manifest.Descendants ("instrumentation").Any (x => (string) x.Attribute (attName) == ia.Name))
					manifest.Add (ia.ToElement (PackageName, cache));
			}

			foreach (TypeDefinition type in subclasses) {
				if (type.IsSubclassOf ("Android.App.Instrumentation", cache)) {
					var xe = InstrumentationFromTypeDefinition (type, JavaNativeTypeManager.ToJniName (type, cache).Replace ('/', '.'), cache);
					if (xe != null)
						manifest.Add (xe);
				}
			}
		}

		public bool SaveIfChanged (TaskLoggingHelper log, string filename)
		{
			MemoryStream stream = MemoryStreamPool.Shared.Rent ();
			try {
				Save (log, stream);
				return Files.CopyIfStreamChanged (stream, filename);
			} finally {
				MemoryStreamPool.Shared.Return (stream);
			}
		}

		public void Save (TaskLoggingHelper log, string filename) =>
			Save ((c, m) => log.LogCodedWarning (c, m), filename);

		public void Save (Action<string, string> logCodedWarning, string filename)
		{
			using (var file = new StreamWriter (filename, append: false, encoding: Files.UTF8withoutBOM))
				Save (logCodedWarning, file);
		}

		public void Save (TaskLoggingHelper log, Stream stream, bool removeNodes = false) =>
			Save ((c, m) => log.LogCodedWarning (c, m), stream, removeNodes: removeNodes);

		public void Save (Action<string, string> logCodedWarning, Stream stream, bool removeNodes = false)
		{
			using (var file = new StreamWriter (stream, Files.UTF8withoutBOM, bufferSize: 1024, leaveOpen: true))
				Save (logCodedWarning, file, removeNodes: removeNodes);
		}

		public void Save (Action<string, string> logCodedWarning, TextWriter stream, bool removeNodes = false)
		{
			RemoveDuplicateElements ();
			if (removeNodes)
				RemoveNodes ();
			string s;
			var ms = MemoryStreamPool.Shared.Rent ();
			try {
				doc.Save (ms);
				ms.Flush ();
				ms.Position = 0;
				s = new StreamReader (ms).ReadToEnd ();
			} finally {
				MemoryStreamPool.Shared.Return (ms);
			}
			if (!string.IsNullOrEmpty (PackageName))
				s = s.Replace ("${applicationId}", PackageName);
			s = ReplacePlaceholders (Placeholders, s, logCodedWarning);
			stream.Write (s);
		}

		public string GetLaunchableActivityName ()
		{
			var application = doc.Root.Descendants ("application").FirstOrDefault ();
			var aName = androidNs + "name";
			foreach (var activity in application.Elements ("activity")) {
				var filter = activity.Element ("intent-filter");
				if (filter != null) {
					foreach (var category in filter.Elements ("category"))
						if (category != null && (string)category.Attribute (aName) == "android.intent.category.LAUNCHER")
							return (string) activity.Attribute (aName);
				}
			}
			return null;
		}

		static int GetAbiCode (string abi)
		{
			switch (abi) {
			case "armeabi-v7a":
				return 2;
			case "x86":
				return 3;
			case "arm64-v8a":
				return 4;
			case "x86_64":
				return 5;
			default:
				throw new ArgumentOutOfRangeException ("abi", "unsupported ABI");
			}
		}

		internal static string ReplacePlaceholders (string [] placeholders, string text, Action<string, string> logCodedWarning = null)
		{
			string result = text;
			if (placeholders == null)
				return result;
			foreach (var entry in placeholders.Select (e => e.Split (new char [] {'='}, 2, StringSplitOptions.None))) {
				if (entry.Length == 2)
					result = result.Replace ("${" + entry [0] + "}", entry [1]);
				else {
					if (logCodedWarning != null)
						logCodedWarning ("XA1010", string.Format (Properties.Resources.XA1010, string.Join (";", placeholders)));
				}
			}
			return result;
		}

		public void SetAbi (string abi)
		{
			int code = 1;
			if (!string.IsNullOrEmpty (VersionCode)) {
				code = Convert.ToInt32 (VersionCode);
				if (code > maxVersionCode || code < 0)
					throw new ArgumentOutOfRangeException ("VersionCode", $"VersionCode is outside 0, {maxVersionCode} interval");
			}
			code |= GetAbiCode (abi) << 16;
			VersionCode = code.ToString ();
		}

		public bool ValidateVersionCode (out string error, out string errorCode)
		{
			int code;
			error = errorCode = string.Empty;
			if (!int.TryParse (VersionCode, out code)) {
				error = string.Format (Properties.Resources.XA0003, VersionCode);
				errorCode = "XA0003";
				return false;
			}
			if (code > maxVersionCode || code < 0) {
				error = string.Format (Properties.Resources.XA0004, code, maxVersionCode);
				errorCode = "XA0004";
				return false;
			}
			return true;
		}

		public void CalculateVersionCode (string currentAbi, string versionCodePattern, string versionCodeProperties)
		{
			var regex = new Regex ("\\{(?<key>([A-Za-z]+)):?[D0-9]*[\\}]");
			var kvp = new Dictionary<string, int> ();
			foreach (var item in versionCodeProperties?.Split (new char [] { ';', ':' }) ?? Array.Empty<string> ()) {
				var keyValue = item.Split (new char [] { '=' });
				int val;
				if (!int.TryParse (keyValue [1], out val))
					continue;
				kvp.Add (keyValue [0], val);
			}
			if (!kvp.ContainsKey ("abi") && !string.IsNullOrEmpty (currentAbi))
				kvp.Add ("abi", GetAbiCode (currentAbi));
			if (!kvp.ContainsKey ("versionCode")) {
				if (int.TryParse (VersionCode, out int parsedCode)) {
					kvp.Add ("versionCode", parsedCode);
				} else {
					throw new ArgumentOutOfRangeException ("VersionCode", $"VersionCode {VersionCode} is invalid. It must be an integer value.");
				}
			}
			if (!kvp.ContainsKey ("minSDK") &&
					int.TryParse (GetMinimumSdk (), out var minSdk)) {
				kvp.Add ("minSDK", minSdk);
			}
			var versionCode = String.Empty;
			foreach (Match match in regex.Matches (versionCodePattern)) {
				var key = match.Groups ["key"].Value;
				var format = match.Value.Replace (key, "0");
				if (!kvp.ContainsKey (key))
					continue;
				versionCode += string.Format (format, kvp [key]);
			}
			VersionCode = versionCode.TrimStart ('0');
		}
	}

	// Allow these methods to be mocked for testing instead of always calling a static class
	public interface IVersionResolver
	{
		string? GetIdFromApiLevel (string apiLevel);
		int? GetApiLevelFromId (string id);
	}

	class MonoAndroidHelperVersionResolver : IVersionResolver
	{
		public string? GetIdFromApiLevel (string apiLevel)
			=> MonoAndroidHelper.SupportedVersions.GetIdFromApiLevel (apiLevel);

		public int? GetApiLevelFromId (string id)
			=> MonoAndroidHelper.SupportedVersions.GetApiLevelFromId (id);
	}
}
