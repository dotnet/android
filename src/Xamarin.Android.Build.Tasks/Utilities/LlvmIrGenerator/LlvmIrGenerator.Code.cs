using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;

namespace Xamarin.Android.Tasks.LLVMIR
{
	abstract partial class LlvmIrGenerator
	{
		// In code generated by clang, function attributes are determined based on the compiler optimization,
		// security arguments, architecture specific flags and so on.  For our needs we will have but a
		// handful of such sets, based on what clang generates for our native runtime.  As such, there is nothing
		// "smart" about how we select the attributes, they must match the compiler output for XA runtime, that's all.
		//
		// Sets are initialized here with the options common to all architectures, the rest is added in the architecture
		// specific derived classes.
		//
		public const int FunctionAttributesXamarinAppInit = 0;
		public const int FunctionAttributesJniMethods = 1;
		public const int FunctionAttributesCall = 2;
		public const int FunctionAttributesLlvmLifetime = 3;
		public const int FunctionAttributesLibcFree = 4;

		protected readonly Dictionary<int, LlvmFunctionAttributeSet> FunctionAttributes = new Dictionary<int, LlvmFunctionAttributeSet> ();

		bool codeOutputInitialized = false;
		List<LlvmIrFunction>? externalFunctions = null;
		LlvmIrVariableReference? llvm_lifetime_start_p0i8_ref;
		LlvmIrVariableReference? llvm_lifetime_end_p0i8_ref;
		List<LlvmIrFunctionParameter>? llvm_lifetime_start_end_params;

		public void WriteFunctionDeclarations ()
		{
			if (externalFunctions == null || externalFunctions.Count == 0) {
				return;
			}

			WriteEOL ();
			WriteCommentLine ();
			WriteCommentLine ("External functions");
			WriteCommentLine ();

			foreach (LlvmIrFunction func in externalFunctions) {
				WriteFunctionForwardDeclaration (func);
			}
		}

		public void AddExternalFunction (LlvmIrFunction func)
		{
			if (externalFunctions == null) {
				externalFunctions = new List<LlvmIrFunction> ();
			}

			externalFunctions.Add (func);
		}

		void ValidateFunction (LlvmIrFunction function, out LlvmFunctionAttributeSet? attributes)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			attributes = null;
			if (function.AttributeSetID >= 0 && !FunctionAttributes.TryGetValue (function.AttributeSetID, out attributes)) {
				throw new InvalidOperationException ($"Function '{function.Name}' refers to attribute set that does not exist (ID: {function.AttributeSetID})");
			}
		}

		void WriteFunctionSignature (LlvmIrFunction function, string statementKindKeyword, LlvmFunctionAttributeSet? attributes, string? comment, bool writeParameterNames = true)
		{
			if (!String.IsNullOrEmpty (comment)) {
				foreach (string line in comment.Split ('\n')) {
					WriteCommentLine (line);
				}
			}

			if (attributes != null) {
				WriteCommentLine ($"Function attributes: {attributes.Render ()}");
			}

			Output.Write ($"{statementKindKeyword} {GetKnownIRType (function.ReturnType)} @{function.Name} (");
			WriteFunctionParameters (function.Parameters, writeNames: writeParameterNames);
			Output.Write(") local_unnamed_addr ");
			if (attributes != null) {
				Output.Write ($"#{function.AttributeSetID.ToString (CultureInfo.InvariantCulture)}");
			}
		}

		/// <summary>
		/// Writes function forward declaration
		/// </summary>
		public void WriteFunctionForwardDeclaration (LlvmIrFunction function, string? comment = null)
		{
			ValidateFunction (function, out LlvmFunctionAttributeSet? attributes);

			Output.WriteLine ();
			WriteFunctionSignature (function, "declare", attributes, comment, writeParameterNames: false);
			Output.WriteLine (";");
		}

		/// <summary>
		/// Writes the function definition up to the opening curly brace
		/// </summary>
		public void WriteFunctionStart (LlvmIrFunction function, string? comment = null)
		{
			ValidateFunction (function, out LlvmFunctionAttributeSet? attributes);
			Output.WriteLine ();
			WriteFunctionSignature (function, "define", attributes, comment);
			Output.WriteLine ();
			Output.WriteLine ("{");
		}

		void CodeRenderType (LlvmIrVariable variable, StringBuilder? builder = null, bool ignoreNativePointer = false)
		{
			string extraPointer = !ignoreNativePointer && variable.IsNativePointer ? "*" : String.Empty;

			if (variable.NativeFunction != null) {
				if (builder == null) {
					WriteFunctionSignature (variable.NativeFunction);
					if (extraPointer.Length > 0) {
						Output.Write (extraPointer);
					}
				} else {
					builder.Append (RenderFunctionSignature (variable.NativeFunction));
					if (extraPointer.Length > 0) {
						builder.Append (extraPointer);
					}
				}
				return;
			}

			StringBuilder? flags = null;
			if (variable is LlvmIrFunctionParameter fparam) {
				if (fparam.IsVarargs) {
					DoWrite ("...");
					return;
				}

				flags = new StringBuilder ();
				if (fparam.NoCapture) {
					flags.Append (" nocapture");
				}

				if (fparam.Immarg) {
					flags.Append (" immarg");
				}

				if (fparam.NoUndef) {
					flags.Append (" noundef");
				}
			}

			string irType = $"{GetKnownIRType (variable.Type)}{extraPointer}{flags?.ToString() ?? String.Empty}";
			DoWrite (irType);

			void DoWrite (string s)
			{
				if (builder == null) {
					Output.Write (s);
				} else {
					builder.Append (s);
				}
			}
		}

		void WriteFunctionParameters (IList<LlvmIrFunctionParameter>? parameters, bool writeNames)
		{
			string rendered = RenderFunctionParameters (parameters, writeNames);
			if (String.IsNullOrEmpty (rendered)) {
				return;
			}

			Output.Write (rendered);
		}

		public string RenderFunctionParameters (IList<LlvmIrFunctionParameter>? parameters, bool writeNames)
		{
			if (parameters == null || parameters.Count == 0) {
				return String.Empty;
			}

			var sb = new StringBuilder ();
			bool first = true;
			foreach (LlvmIrFunctionParameter p in parameters) {
				if (!first) {
					sb.Append (", ");
				} else {
					first = false;
				}

				CodeRenderType (p, sb);

				if (writeNames) {
					if (String.IsNullOrEmpty (p.Name)) {
						throw new InvalidOperationException ("Parameter name is required");
					}

					sb.Append ($" %{p.Name}");
				}
			}

			return sb.ToString ();
		}

		public void WriteFunctionSignature (LlvmNativeFunctionSignature sig, bool isPointer = true)
		{
			Output.Write (RenderFunctionSignature (sig, isPointer));
		}

		public string RenderFunctionSignature (LlvmNativeFunctionSignature sig, bool isPointer = true)
		{
			if (sig == null) {
				throw new ArgumentNullException (nameof (sig));
			}

			var sb = new StringBuilder ();
			sb.Append (GetKnownIRType (sig.ReturnType));
			sb.Append (" (");
			sb.Append (RenderFunctionParameters (sig.Parameters, writeNames: false));
			sb.Append (")");
			if (isPointer) {
				sb.Append ('*');
			}

			return sb.ToString ();
		}

		/// <summary>
		/// Writes the epilogue of a function, including the return statement <b>if</b> the function return
		/// type is <c>void</c>.
		/// </summary>
		public void WriteFunctionEnd (LlvmIrFunction function)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			if (function.ReturnType == typeof (void)) {
				EmitReturnInstruction (function);
			}

			Output.WriteLine ("}");
		}

		/// <summary>
		/// Emits the <c>ret</c> statement using <paramref name="retvar"/> as the returned value. If <paramref name="retvar"/>
		/// is <c>null</c>, <c>void</c> is used as the return value.
		/// </summary>
		public void EmitReturnInstruction (LlvmIrFunction function, LlvmIrFunctionLocalVariable? retVar = null)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			string ret = retVar != null ? $"{GetKnownIRType(retVar.Type)} %{retVar.Name}" : "void";
			Output.WriteLine ($"{function.Indent}ret {ret}");
		}

		/// <summary>
		/// Emits the <c>store</c> instruction (https://llvm.org/docs/LangRef.html#store-instruction), which stores data from a local
		/// variable into either local or global destination. If types of <paramref name="source"/> and <paramref name="destination"/>
		/// differ, <paramref name="destination"/> is bitcast to the type of <paramref name="source"/>.  It is responsibility of the
		/// caller to make sure the two types are compatible and/or convertible to each other.
		/// <summary>
		public void EmitStoreInstruction (LlvmIrFunction function, LlvmIrFunctionLocalVariable source, LlvmIrVariableReference destination)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			// TODO: implement bitcast, if necessary
			Output.Write ($"{function.Indent}store ");
			CodeRenderType (source);
			Output.Write ($" %{source.Name}, ");
			CodeRenderType (destination);
			Output.WriteLine ($"* {destination.Reference}, align {GetTypeSize (destination.Type).ToString (CultureInfo.InvariantCulture)}");
		}

		public void EmitStoreInstruction<T> (LlvmIrFunction function, LlvmIrVariableReference destination, T? value)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			if (typeof(T) != destination.Type) {
				throw new InvalidOperationException ($"Destination variable is of type '{destination.Type}', it cannot be assigned a value of type {typeof(T)}");
			}

			if (value == null && typeof(T) != typeof(string) && typeof(T) != typeof(IntPtr) && !destination.IsNativePointer) {
				throw new InvalidOperationException ($"Cannot assign a NULL pointer value to variable of non-pointer type '{destination.Type}'");
			}

			Output.Write ($"{function.Indent}store ");
			CodeRenderType (destination, ignoreNativePointer: true);
			Output.Write (' ');
			if (value == null) {
				Output.Write ("null");
			} else {
				Output.Write (MonoAndroidHelper.CultureInvariantToString (value));
			}
			Output.Write (", ");
			CodeRenderType (destination);
			Output.WriteLine ($" {destination.Reference}, align {GetTypeSize (destination.Type).ToString (CultureInfo.InvariantCulture)}");
		}

		/// <summary>
		/// Emits the <c>load</c> instruction (https://llvm.org/docs/LangRef.html#load-instruction)
		/// </summary>
		public LlvmIrFunctionLocalVariable EmitLoadInstruction (LlvmIrFunction function, LlvmIrVariableReference source, string? resultVariableName = null)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			LlvmIrFunctionLocalVariable result = function.MakeLocalVariable (source, resultVariableName);
			Output.Write ($"{function.Indent}%{result.Name} = load ");
			CodeRenderType (source, ignoreNativePointer: true);
			Output.Write (", ");
			CodeRenderType (source);
			if (!source.IsNativePointer) {
				Output.Write ('*');
			}

			Output.WriteLine ($" {source.Reference}, align {PointerSize.ToString (CultureInfo.InvariantCulture)}");

			return result;
		}

		/// <summary>
		/// Emits the <c>icmp</c> comparison instruction (https://llvm.org/docs/LangRef.html#icmp-instruction)
		/// </summary>
		public LlvmIrFunctionLocalVariable EmitIcmpInstruction (LlvmIrFunction function, LlvmIrIcmpCond cond, LlvmIrVariableReference variable, string expectedValue, string? resultVariableName = null)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			string condOp;
			switch (cond) {
				case LlvmIrIcmpCond.Equal:  // equal
					condOp = "eq";
					break;

				case LlvmIrIcmpCond.NotEqual:  // not equal
					condOp = "ne";
					break;

				case LlvmIrIcmpCond.UnsignedGreaterThan: // unsigned greater than
					condOp = "ugt";
					break;

				case LlvmIrIcmpCond.UnsignedGreaterOrEqual: // unsigned greater or equal
					condOp = "uge";
					break;

				case LlvmIrIcmpCond.UnsignedLessThan: // unsigned less than
					condOp = "ult";
					break;

				case LlvmIrIcmpCond.UnsignedLessOrEqual: // unsigned less or equal
					condOp = "ule";
					break;

				case LlvmIrIcmpCond.SignedGreaterThan: // signed greater than,
					condOp = "sgt";
					break;

				case LlvmIrIcmpCond.SignedGreaterOrEqual: // signed greater or equal
					condOp = "sge";
					break;

				case LlvmIrIcmpCond.SignedLessThan: // signed less than
					condOp = "slt";
					break;

				case LlvmIrIcmpCond.SignedLessOrEqual: // signed less or equal
					condOp = "sle";
					break;

				default:
					throw new InvalidOperationException ($"Unsupported `icmp` conditional '{cond}'");
			}

			var sb = new StringBuilder ();
			CodeRenderType (variable, sb);

			string variableType = sb.ToString ();
			LlvmIrFunctionLocalVariable result = function.MakeLocalVariable (variable.Type, resultVariableName);

			Output.WriteLine ($"{function.Indent}%{result.Name} = icmp {condOp} {variableType} {variable.Reference}, {expectedValue}");

			return result;
		}

		public void EmitBrInstruction (LlvmIrFunction function, LlvmIrVariableReference condVariable, string labelTrue, string labelFalse)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			Output.WriteLine ($"{function.Indent}br i1 {condVariable.Reference}, label %{labelTrue}, label %{labelFalse}");
		}

		public void EmitBrInstruction (LlvmIrFunction function, string label)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			Output.WriteLine ($"{function.Indent}br label %{label}");
		}

		public void EmitLabel (LlvmIrFunction function, string labelName, bool insertNewlineBefore = true)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			if (insertNewlineBefore) {
				Output.WriteLine ();
			}

			Output.WriteLine ($"{function.MakeLabel (labelName)}:");
		}

		public LlvmIrFunctionLocalVariable EmitUpcast (LlvmIrFunction function, LlvmIrVariableReference sourceRef, Type targetType)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			if (sourceRef == null) {
				throw new ArgumentNullException (nameof (sourceRef));
			}

			if (targetType == null) {
				throw new ArgumentNullException (nameof (targetType));
			}

			string extendOp;
			if (targetType == typeof(double)) {
				extendOp = "fp";
			} else if (targetType == typeof(int)) {
				extendOp = "s";
			} else if (targetType == typeof(uint)) {
				extendOp = "z";
			} else {
				throw new InvalidOperationException ($"Unsupported target type for upcasting: {targetType}");
			}

			LlvmIrFunctionLocalVariable result = function.MakeLocalVariable (targetType);
			Output.WriteLine ($"{function.Indent}%{result.Name} = {extendOp}ext {GetKnownIRType (sourceRef.Type)} {sourceRef.Reference} to {GetKnownIRType (targetType)}");

			return result;
		}

		void WriteCallArgument (LlvmIrFunction function, LlvmIrFunctionArgument argument, LlvmIrFunctionParameter? parameter, bool variadicCountry, int argumentIndex)
		{
			string paramType;
			if (!variadicCountry) {
				AssertValidType (argumentIndex, parameter, argument);

				paramType = GetParameterType (parameter);
			} else {
				paramType = GetArgumentType (argument);
			}

			Output.Write ($"{paramType} ");

			if (argument.NonNull) {
				Output.Write ("nonnull ");
			}

			if (argument.NoUndef) {
				Output.Write ("noundef ");
			}

			if (argument.Value is LlvmIrFunctionLocalVariable variable) {
				Output.Write ($"%{variable.Name}");
				return;
			}

			if (argument.Value is StringSymbolInfo stringSymbol) {
				WriteGetStringPointer (stringSymbol.SymbolName, stringSymbol.Size, indent: false, detectBitness: true, skipPointerType: true);
				return;
			}

			if (argument.Type.IsNativePointer () || argument.IsNativePointer) {
				if (parameter != null && parameter.IsCplusPlusReference) {
					Output.Write ("nonnull ");
				}

				if (argument.Type == typeof(LlvmIrVariableReference)) {
					var variableRef = argument.Value as LlvmIrVariableReference;
					bool needBitcast = parameter == null || variableRef == null ? false : parameter.Type != variableRef.Type;

					if (needBitcast) {
						string ptrSize = PointerSize.ToString (CultureInfo.InvariantCulture);
						Output.Write ($"align {ptrSize} dereferenceable({ptrSize}) bitcast (");
						CodeRenderType (variableRef);
						Output.Write (' ');
					}

					if (variableRef != null) {
						Output.Write (variableRef.Reference);
					} else {
						Output.Write ("null");
					}

					if (needBitcast) {
						Output.Write ($" to {paramType})");
					}
				} else {
					throw new InvalidOperationException ($"Unexpected pointer type in argument {argumentIndex}, '{argument.Type}'");
				}
				return;
			}

			if (argument.Value is string str) {
				StringSymbolInfo info = StringManager.Add (str);
				WriteGetStringPointer (info.SymbolName, info.Size, indent: false, detectBitness: true, skipPointerType: true);
				return;

			}

			Output.Write (MonoAndroidHelper.CultureInvariantToString (argument.Value));

			string GetArgumentType (LlvmIrFunctionArgument argument)
			{
				string extra = argument.IsNativePointer ? "*" : String.Empty;

				Type type;
				if (argument.Value is LlvmIrFunctionLocalVariable variable) {
					type = variable.Type;
				} else if (argument.Value is StringSymbolInfo stringSymbol) {
					type = typeof(string);
				} else {
					type = argument.Type;
				}

				return $"{GetKnownIRType (type)}{extra}";
			}

			static void AssertValidType (int index, LlvmIrFunctionParameter parameter, LlvmIrFunctionArgument argument)
			{
				if (argument.Type == typeof(LlvmIrFunctionLocalVariable) || argument.Type == typeof(LlvmIrVariableReference)) {
					return;
				}

				if (parameter.Type != typeof(IntPtr)) {
					if (argument.Type == typeof(StringSymbolInfo) && parameter.Type == typeof (string)) {
						// Fine, we want to pass a pointer to string
						return;
					}

					if (argument.Type != parameter.Type) {
						ThrowException ();
					}
					return;
				}

				if (argument.Type.IsNativePointer ()) {
					return;
				}

				if (typeof(LlvmIrVariable).IsAssignableFrom (argument.Type) &&
				    argument.Value is LlvmIrVariable variable &&
				    (variable.IsNativePointer || variable.NativeFunction != null)) {
					return;
				}

				ThrowException ();

				void ThrowException ()
				{
					throw new InvalidOperationException ($"Argument {index} type '{argument.Type}' does not match the expected function parameter type '{parameter.Type}'");
				}
			}
		}

		void WriteCallArguments (LlvmIrFunction function, LlvmNativeFunctionSignature targetSignature, List<LlvmIrFunctionArgument> arguments)
		{
			bool variadicCountry = false;
			for (int i = 0; i < arguments.Count; i++) {
				LlvmIrFunctionParameter? parameter = null;

				if (!variadicCountry) {
					if (i >= targetSignature.Parameters.Count) {
						throw new InvalidOperationException ("Internal error: Exceeded number of declared parameters, expected a trailing variadic parameter at this point");
					}

					parameter = targetSignature.Parameters[i];

					if (parameter.IsVarargs) {
						variadicCountry = true;
					}
				}

				if (i > 0) {
					Output.Write (", ");
				}

				WriteCallArgument (function, arguments[i], parameter, variadicCountry, i);
			}
		}

		public LlvmIrFunctionLocalVariable? EmitCall (LlvmIrFunction function, LlvmIrVariableReference targetRef, List<LlvmIrFunctionArgument>? arguments = null,
		                                              string? resultVariableName = null, LlvmIrCallMarker marker = LlvmIrCallMarker.Tail, int AttributeSetID = FunctionAttributesCall)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			if (targetRef == null) {
				throw new ArgumentNullException (nameof (targetRef));
			}

			LlvmNativeFunctionSignature targetSignature = targetRef.NativeFunction;
			if (targetSignature == null) {
				throw new ArgumentException ("must be reference to native function", nameof (targetRef));
			}

			bool haveParameters = targetSignature.Parameters != null && targetSignature.Parameters.Count > 0;
			if (haveParameters) {
				if (arguments == null) {
					throw new ArgumentNullException (nameof (arguments));
				}

				if ((targetSignature.IsVariadic && targetSignature.NumberOfRequiredArguments > arguments.Count) || (!targetSignature.IsVariadic && targetSignature.NumberOfRequiredArguments != arguments.Count)) {
					throw new ArgumentException ($"number of passed parameters ({arguments.Count}) does not match number of required parameters in function signature ({targetSignature.NumberOfRequiredArguments})", nameof (arguments));
				}
			}

			bool returnsValue = targetSignature.ReturnType != typeof(void);
			LlvmIrFunctionLocalVariable? result = null;

			Output.Write (function.Indent);
			if (returnsValue) {
				result = function.MakeLocalVariable (targetSignature.ReturnType, resultVariableName);
				Output.Write ($"%{result.Name} = ");
			}

			switch (marker) {
				case LlvmIrCallMarker.Tail:
					Output.Write ("tail ");
					break;

				case LlvmIrCallMarker.MustTail:
					Output.Write ("musttail ");
					break;

				case LlvmIrCallMarker.NoTail:
					Output.Write ("notail ");
					break;

				case LlvmIrCallMarker.None:
					break;

				default:
					throw new InvalidOperationException ($"Unsupported call marker '{marker}'");
			}

			Output.Write ($"call {GetKnownIRType (targetSignature.ReturnType)} ");
			if (targetSignature.IsVariadic) {
				Output.Write ('(');
				for (int i = 0; i < targetSignature.NumberOfRequiredArguments; i++) {
					if (i > 0) {
						Output.Write (", ");
					}
					LlvmIrFunctionParameter argument = targetSignature.Parameters[i];
					Output.Write (GetParameterType (argument));
				}
				Output.Write (", ...) "); // We know the variadic parameter is last
			}
			Output.Write ($"{targetRef.Reference} (");

			if (haveParameters) {
				WriteCallArguments (function, targetSignature, arguments);
			}

			Output.Write (")");

			if (AttributeSetID >= 0) {
				if (!FunctionAttributes.ContainsKey (AttributeSetID)) {
					throw new InvalidOperationException ($"Unknown attribute set ID {AttributeSetID}");
				}
				Output.Write ($" #{AttributeSetID.ToString (CultureInfo.InvariantCulture)}");
			}
			Output.WriteLine ();

			return result;
		}

		string GetParameterType (LlvmIrFunctionParameter parameter)
		{
			string extra = parameter.IsNativePointer ? "*" : String.Empty;
			return $"{GetKnownIRType (parameter.Type)}{extra}";
		}

		/// <summary>
		/// Emits the <c>phi</c> instruction (https://llvm.org/docs/LangRef.html#phi-instruction) for a function pointer type
		/// </summary>
		public LlvmIrFunctionLocalVariable EmitPhiInstruction (LlvmIrFunction function, LlvmIrVariableReference target, List<(LlvmIrVariableReference? variableRef, string label)> pairs, string? resultVariableName = null)
		{
			if (function == null) {
				throw new ArgumentNullException (nameof (function));
			}

			LlvmIrFunctionLocalVariable result = function.MakeLocalVariable (target, resultVariableName);
			Output.Write ($"{function.Indent}%{result.Name} = phi ");
			CodeRenderType (target, ignoreNativePointer: true);

			bool first = true;
			foreach ((LlvmIrVariableReference variableRef, string label) in pairs) {
				if (first) {
					first = false;
					Output.Write (' ');
				} else {
					Output.Write (", ");
				}

				string value = variableRef?.Reference ?? "null";
				Output.Write ($"[{value}, %{label}]");
			}
			Output.WriteLine ();

			return result;
		}

		void RegisterLlvmLifetimeTrackerFunctions ()
		{
			if (llvm_lifetime_start_p0i8_ref != null && llvm_lifetime_end_p0i8_ref != null) {
				return;
			}

			const string llvm_lifetime_start_p0i8_name = "llvm.lifetime.start.p0i8";
			const string llvm_lifetime_end_p0i8_name = "llvm.lifetime.end.p0i8";

			llvm_lifetime_start_end_params = new List<LlvmIrFunctionParameter> {
				new LlvmIrFunctionParameter (typeof(long)) {
					Immarg = true,
				},
				new LlvmIrFunctionParameter (typeof(sbyte), isNativePointer: true) {
					NoCapture = true,
				},
			};

			if (llvm_lifetime_start_p0i8_ref == null) {
				var llvm_lifetime_start_p0i8_sig = new LlvmNativeFunctionSignature (
					returnType: typeof(void),
					parameters: llvm_lifetime_start_end_params
				);

				llvm_lifetime_start_p0i8_ref = new LlvmIrVariableReference (llvm_lifetime_start_p0i8_sig, llvm_lifetime_start_p0i8_name, isGlobal: true);
				AddFunctionDeclaration (llvm_lifetime_start_p0i8_name, llvm_lifetime_start_p0i8_sig, LlvmIrGenerator.FunctionAttributesLlvmLifetime);
			}

			if (llvm_lifetime_end_p0i8_ref == null) {
				var llvm_lifetime_end_p0i8_sig = new LlvmNativeFunctionSignature (
					returnType: typeof(void),
					parameters: llvm_lifetime_start_end_params
				);

				llvm_lifetime_end_p0i8_ref = new LlvmIrVariableReference (llvm_lifetime_end_p0i8_sig, llvm_lifetime_end_p0i8_name, isGlobal: true);
				AddFunctionDeclaration (llvm_lifetime_end_p0i8_name, llvm_lifetime_end_p0i8_sig, LlvmIrGenerator.FunctionAttributesLlvmLifetime);
			}

			void AddFunctionDeclaration (string name, LlvmNativeFunctionSignature sig, int attributeSetID)
			{
				var func = new LlvmIrFunction (
					name: name,
					returnType: sig.ReturnType,
					attributeSetID: attributeSetID,
					parameters: sig.Parameters
				);
				AddExternalFunction (func);
			}
		}

		public (LlvmIrFunctionLocalVariable variable, LlvmIrFunctionLocalVariable lifetimeTracker) EmitAllocStackVariable (LlvmIrFunction function, Type type, string? name = null)
		{
			RegisterLlvmLifetimeTrackerFunctions ();

			string alignment = PointerSize.ToString (CultureInfo.InvariantCulture);
			LlvmIrFunctionLocalVariable localVariable = function.MakeLocalVariable (type, name, isNativePointer: true);
			LlvmIrFunctionLocalVariable lifetimeTracker = function.MakeLocalVariable (localVariable.Type);

			string localVariableTypeName = GetKnownIRType (localVariable.Type);
			Output.WriteLine ($"{function.Indent}%{localVariable.Name} = alloca {localVariableTypeName}, align {alignment}");
			Output.WriteLine ($"{function.Indent}%{lifetimeTracker.Name} = bitcast {GetKnownIRType (lifetimeTracker.Type)}* %{localVariable.Name} to {localVariableTypeName}");

			var lifetimeStartArgs = new List<LlvmIrFunctionArgument> {
				new LlvmIrFunctionArgument (llvm_lifetime_start_end_params[0], (long)PointerSize),
				new LlvmIrFunctionArgument (lifetimeTracker) {
					NonNull = true,
				},
			};

			EmitCall (function, llvm_lifetime_start_p0i8_ref, lifetimeStartArgs, marker: LlvmIrCallMarker.None, AttributeSetID: FunctionAttributesLlvmLifetime);
			return (localVariable, lifetimeTracker);
		}

		public void EmitDeallocStackVariable (LlvmIrFunction function, LlvmIrFunctionLocalVariable lifetimeTracker)
		{
			RegisterLlvmLifetimeTrackerFunctions ();

			var lifetimeEndArgs = new List<LlvmIrFunctionArgument> {
				new LlvmIrFunctionArgument (llvm_lifetime_start_end_params[0], (long)PointerSize),
				new LlvmIrFunctionArgument (lifetimeTracker) {
					NonNull = true,
				},
			};

			EmitCall (function, llvm_lifetime_end_p0i8_ref, lifetimeEndArgs, marker: LlvmIrCallMarker.None, AttributeSetID: FunctionAttributesLlvmLifetime);
		}

		public void InitCodeOutput ()
		{
			if (codeOutputInitialized) {
				return;
			}

			InitFunctionAttributes ();
			InitCodeMetadata ();
			codeOutputInitialized = true;
		}

		protected virtual void InitCodeMetadata ()
		{
			MetadataManager.Add ("llvm.linker.options");
		}

		protected virtual void InitFunctionAttributes ()
		{
			FunctionAttributes[FunctionAttributesXamarinAppInit] = new LlvmFunctionAttributeSet {
				new MinLegalVectorWidthFunctionAttribute (0),
				new MustprogressFunctionAttribute (),
				new NofreeFunctionAttribute (),
				new NorecurseFunctionAttribute (),
				new NosyncFunctionAttribute (),
				new NoTrappingMathFunctionAttribute (true),
				new NounwindFunctionAttribute (),
				new SspstrongFunctionAttribute (),
				new StackProtectorBufferSizeFunctionAttribute (8),
//				new UwtableFunctionAttribute (),
				new WillreturnFunctionAttribute (),
				new WriteonlyFunctionAttribute (),
			};

			FunctionAttributes[FunctionAttributesJniMethods] = new LlvmFunctionAttributeSet {
				new MinLegalVectorWidthFunctionAttribute (0),
				new MustprogressFunctionAttribute (),
				new NoTrappingMathFunctionAttribute (true),
				new NounwindFunctionAttribute (),
				new SspstrongFunctionAttribute (),
				new StackProtectorBufferSizeFunctionAttribute (8),
//				new UwtableFunctionAttribute (),
			};

			FunctionAttributes[FunctionAttributesCall] = new LlvmFunctionAttributeSet {
				new NounwindFunctionAttribute (),
			};

			FunctionAttributes[FunctionAttributesLlvmLifetime] = new LlvmFunctionAttributeSet {
				new ArgmemonlyFunctionAttribute (),
				new MustprogressFunctionAttribute (),
				new NofreeFunctionAttribute (),
				new NosyncFunctionAttribute (),
				new NounwindFunctionAttribute (),
				new WillreturnFunctionAttribute (),
			};

			FunctionAttributes[FunctionAttributesLibcFree] = new LlvmFunctionAttributeSet {
				new InaccessiblememOrArgmemonlyFunctionAttribute (),
				new MustprogressFunctionAttribute (),
				new NounwindFunctionAttribute (),
				new WillreturnFunctionAttribute (),
			};

			FunctionAttributes[FunctionAttributesLibcFree].Add (FunctionAttributes[FunctionAttributesJniMethods]);
		}

		void WriteAttributeSets ()
		{
			if (!codeOutputInitialized) {
				return;
			}

			WriteSet (FunctionAttributesXamarinAppInit, Output);
			WriteSet (FunctionAttributesJniMethods, Output);
			WriteSet (FunctionAttributesCall, Output);
			WriteSet (FunctionAttributesLlvmLifetime, Output);
			WriteSet (FunctionAttributesLibcFree, Output);

			Output.WriteLine ();

			void WriteSet (int id, TextWriter output)
			{
				output.Write ($"attributes #{id.ToString (CultureInfo.InvariantCulture)} = {{ ");
				foreach (LLVMFunctionAttribute attr in FunctionAttributes[id]) {
					output.Write (attr.Render ());
					output.Write (' ');
				}
				output.WriteLine ("}");
			}
		}
	}
}
