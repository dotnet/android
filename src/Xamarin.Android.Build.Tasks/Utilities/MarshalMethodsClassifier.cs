#nullable disable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

using Java.Interop.Tools.Cecil;
using Java.Interop.Tools.TypeNameMappings;

using Microsoft.Android.Build.Tasks;
using Microsoft.Build.Utilities;
using Mono.Cecil;
using Xamarin.Android.Tools;

namespace Xamarin.Android.Tasks
{
	class MethodEntry
	{
		public TypeDefinition DeclaringType { get; }

		public MethodEntry (TypeDefinition declaringType)
		{
			DeclaringType = declaringType ?? throw new ArgumentNullException (nameof (declaringType));
		}
	}

	class MarshalMethodEntry : MethodEntry
	{
		/// <summary>
		/// The "real" native callback, used if it doesn't contain any non-blittable types in its parameters
		/// or return type.
		/// </summary>
		MethodDefinition nativeCallbackReal;

		/// <summary>
		/// Used only when <see cref="NeedsBlittableWorkaround"/> is <c>true</c>. This wrapper is generated by
		/// <see cref="MarshalMethodsAssemblyRewriter" /> when rewriting assemblies, for methods which have either
		/// a non-blittable return type or a parameter of a non-blittable type.
		/// </summary>
		public MethodDefinition? NativeCallbackWrapper { get; set; }
		public MethodDefinition? Connector             { get; }
		public MethodDefinition? RegisteredMethod      { get; }
		public MethodDefinition? ImplementedMethod     { get; }
		public FieldDefinition? CallbackField          { get; }
		public string JniTypeName                      { get; }
		public string JniMethodName                    { get; }
		public string JniMethodSignature               { get; }
		public bool NeedsBlittableWorkaround           { get; }

		public MethodDefinition NativeCallback         => NativeCallbackWrapper ?? nativeCallbackReal;
		public bool IsSpecial                          { get; }

		public MarshalMethodEntry (TypeDefinition declaringType, MethodDefinition nativeCallback, MethodDefinition connector, MethodDefinition
		                           registeredMethod, MethodDefinition implementedMethod, FieldDefinition callbackField, string jniTypeName,
		                           string jniName, string jniSignature, bool needsBlittableWorkaround)
			: base (declaringType)
		{
			nativeCallbackReal = nativeCallback ?? throw new ArgumentNullException (nameof (nativeCallback));
			Connector = connector;  // The connector will not exist for converted marshal methods
			RegisteredMethod = registeredMethod ?? throw new ArgumentNullException (nameof (registeredMethod));
			ImplementedMethod = implementedMethod ?? throw new ArgumentNullException (nameof (implementedMethod));
			CallbackField = callbackField; // we don't require the callback field to exist
			JniTypeName = EnsureNonEmpty (jniTypeName, nameof (jniTypeName));
			JniMethodName = EnsureNonEmpty (jniName, nameof (jniName));
			JniMethodSignature = EnsureNonEmpty (jniSignature, nameof (jniSignature));
			NeedsBlittableWorkaround = needsBlittableWorkaround;
			IsSpecial = false;
		}

		public MarshalMethodEntry (TypeDefinition declaringType, MethodDefinition nativeCallback, string jniTypeName, string jniName, string jniSignature)
			: base (declaringType)
		{
			nativeCallbackReal = nativeCallback ?? throw new ArgumentNullException (nameof (nativeCallback));
			JniTypeName = EnsureNonEmpty (jniTypeName, nameof (jniTypeName));
			JniMethodName = EnsureNonEmpty (jniName, nameof (jniName));
			JniMethodSignature = EnsureNonEmpty (jniSignature, nameof (jniSignature));
			IsSpecial = true;
		}

		public MarshalMethodEntry (MarshalMethodEntry other, MethodDefinition nativeCallback)
			: this (other.DeclaringType, nativeCallback, other.Connector, other.RegisteredMethod,
			        other.ImplementedMethod, other.CallbackField, other.JniTypeName, other.JniMethodName,
			        other.JniMethodSignature, other.NeedsBlittableWorkaround)
		{}

		string EnsureNonEmpty (string s, string argName)
		{
			if (String.IsNullOrEmpty (s)) {
				throw new ArgumentException ("must not be null or empty", argName);
			}

			return s;
		}

		public string GetStoreMethodKey (TypeDefinitionCache tdCache)
		{
			MethodDefinition registeredMethod = RegisteredMethod;
			string typeName = registeredMethod.DeclaringType.FullName.Replace ('/', '+');
			return $"{typeName}, {registeredMethod.DeclaringType.GetPartialAssemblyName (tdCache)}\t{registeredMethod.Name}";
		}
	}

	sealed class ConvertedMarshalMethodEntry : MarshalMethodEntry
	{
		public MethodDefinition ConvertedNativeCallback { get; }

		public ConvertedMarshalMethodEntry (TypeDefinition declaringType, MethodDefinition nativeCallback, MethodDefinition connector, MethodDefinition
					   registeredMethod, MethodDefinition implementedMethod, FieldDefinition callbackField, string jniTypeName,
					   string jniName, string jniSignature, bool needsBlittableWorkaround, MethodDefinition convertedNativeCallback)
			: base (declaringType, nativeCallback, connector, registeredMethod, implementedMethod, callbackField, jniTypeName, jniName, jniSignature, needsBlittableWorkaround)
		{
			ConvertedNativeCallback = convertedNativeCallback ?? throw new ArgumentNullException (nameof (convertedNativeCallback));
		}
	}

	sealed class DynamicallyRegisteredMarshalMethodEntry : MethodEntry
	{
		public MethodDefinition ImplementedMethod { get; }
		public CustomAttribute RegisterAttribute { get; }
		public MethodDefinition RegisteredMethod { get; }

		public DynamicallyRegisteredMarshalMethodEntry (TypeDefinition declaringType, MethodDefinition implementedMethod, MethodDefinition registeredMethod, CustomAttribute registerAttribute)
			: base (declaringType)
		{
			ImplementedMethod = implementedMethod;
			RegisteredMethod = registeredMethod;
			RegisterAttribute = registerAttribute;
		}
	}

	class MarshalMethodsClassifier
	{
		public sealed class ConnectorInfo
		{
			public string MethodName                  { get; }
			public string TypeName                    { get; }
			public AssemblyNameReference AssemblyName { get; }

			public ConnectorInfo (string spec)
			{
				string[] connectorSpec = spec.Split (':');
				MethodName = connectorSpec[0];

				if (connectorSpec.Length < 2) {
					return;
				}

				string fullTypeName = connectorSpec[1];
				int comma = fullTypeName.IndexOf (',');
				TypeName = fullTypeName.Substring (0, comma);
				AssemblyName = AssemblyNameReference.Parse (fullTypeName.Substring (comma + 1).Trim ());
			}
		}

		interface IMethodSignatureMatcher
		{
			bool Matches (MethodDefinition method);
		}

		sealed class NativeCallbackSignature : IMethodSignatureMatcher
		{
			static readonly HashSet<string> verbatimTypes = new HashSet<string> (StringComparer.Ordinal) {
				"System.Boolean",
				"System.Byte",
				"System.Char",
				"System.Double",
				"System.Int16",
				"System.Int32",
				"System.Int64",
				"System.IntPtr",
				"System.SByte",
				"System.Single",
				"System.UInt16",
				"System.UInt32",
				"System.UInt64",
				"System.Void",
			};

			readonly List<string> paramTypes;
			readonly string returnType;
			readonly TaskLoggingHelper log;
			readonly TypeDefinitionCache cache;

			public NativeCallbackSignature (MethodDefinition target, TaskLoggingHelper log, TypeDefinitionCache cache)
			{
				this.log = log;
				this.cache = cache;
				returnType = MapType (target.ReturnType);
				paramTypes = new List<string> {
					"System.IntPtr", // jnienv
					"System.IntPtr", // native__this
				};

				foreach (ParameterDefinition pd in target.Parameters) {
					paramTypes.Add (MapType (pd.ParameterType));
				}
			}

			string MapType (TypeReference typeRef)
			{
				string? typeName = null;
				if (!typeRef.IsGenericParameter && !typeRef.IsArray) {
					TypeDefinition typeDef = cache.Resolve (typeRef);
					if (typeDef == null) {
						throw new InvalidOperationException ($"Unable to resolve type '{typeRef.FullName}'");
					}

					if (typeDef.IsEnum) {
						return GetEnumUnderlyingType (typeDef).FullName;
					}
				}

				if (String.IsNullOrEmpty (typeName)) {
					typeName = typeRef.FullName;
				}

				if (verbatimTypes.Contains (typeName)) {
					return typeName;
				}

				// Android.Graphics.Color is mapped to/from a native `int`
				if (String.Compare (typeName, "Android.Graphics.Color", StringComparison.Ordinal) == 0) {
					return "System.Int32";
				}

				return "System.IntPtr";
			}

			static TypeReference GetEnumUnderlyingType (TypeDefinition td)
			{
				var fields = td.Fields;

				for (int i = 0; i < fields.Count; i++) {
					var field = fields [i];
					if (!field.IsStatic)
						return field.FieldType;
				}

				throw new InvalidOperationException ($"Unable to determine underlying type of the '{td.FullName}' enum");
			}

			public bool Matches (MethodDefinition method)
			{
				if (method.Parameters.Count != paramTypes.Count || !method.IsStatic) {
					log.LogWarning ($"Method '{method.FullName}' doesn't match native callback signature (invalid parameter count or not static)");
					return false;
				}

				if (!TypeMatches (returnType, method.ReturnType.FullName)) {
					log.LogWarning ($"Method '{method.FullName}' doesn't match native callback signature (invalid return type: expected '{returnType}', found '{method.ReturnType.FullName}')");
					return false;
				}

				for (int i = 0; i < method.Parameters.Count; i++) {
					ParameterDefinition pd = method.Parameters[i];
					string parameterTypeName;

					if (pd.ParameterType.IsArray) {
						parameterTypeName = $"{pd.ParameterType.FullName}[]";
					} else {
						parameterTypeName = pd.ParameterType.FullName;
					}

					if (!TypeMatches (parameterTypeName, paramTypes[i])) {
						log.LogWarning ($"Method '{method.FullName}' doesn't match native callback signature, expected parameter type '{paramTypes[i]}' at position {i}, found '{parameterTypeName}'");
						return false;
					}
				}

				return true;
			}

			// Because these types are marshaled as different blittable types,
			// we need to accept them as equivalent
			static readonly (string Source, string Replacement)[] equivalent_types = [
				(Source: "System.Boolean", Replacement: "System.SByte"),
				(Source: "System.Char", Replacement: "System.UInt16"),
			];

			static bool TypeMatches (string type, string methodType)
			{
				if (String.Compare (type, methodType, StringComparison.Ordinal) == 0)
					return true;

				foreach (var eq in equivalent_types) {
					if (string.Compare (eq.Source, type, StringComparison.Ordinal) == 0 && string.Compare (eq.Replacement, methodType, StringComparison.Ordinal) == 0)
						return true;

					if (string.Compare (eq.Source, methodType, StringComparison.Ordinal) == 0 && string.Compare (eq.Replacement, type, StringComparison.Ordinal) == 0)
						return true;
				}

				return false;
			}
		}

		TypeDefinitionCache tdCache;
		IAssemblyResolver resolver;
		TaskLoggingHelper log;
		readonly AndroidTargetArch targetArch;

		public TypeDefinitionCache TypeDefinitionCache => tdCache;
		public TaskLoggingHelper Log => log;
		public IAssemblyResolver Resolver => resolver;

		public MarshalMethodsClassifier (AndroidTargetArch targetArch, TypeDefinitionCache tdCache, IAssemblyResolver res, TaskLoggingHelper log)
		{
			this.targetArch = targetArch;
			this.log = log ?? throw new ArgumentNullException (nameof (log));
			this.tdCache = tdCache ?? throw new ArgumentNullException (nameof (tdCache));
			resolver = res ?? throw new ArgumentNullException (nameof (tdCache));
		}

		public MarshalMethodsClassifier (TypeDefinitionCache tdCache, IAssemblyResolver res, TaskLoggingHelper log)
		{
			this.log = log ?? throw new ArgumentNullException (nameof (log));
			this.tdCache = tdCache ?? throw new ArgumentNullException (nameof (tdCache));
			resolver = res ?? throw new ArgumentNullException (nameof (tdCache));
		}

		public MethodEntry ClassifyMethod (TypeDefinition topType, MethodDefinition registeredMethod, MethodDefinition implementedMethod, CustomAttribute? registerAttribute)
		{
			topType = topType ?? throw new ArgumentNullException (nameof (topType));
			registeredMethod = registeredMethod ?? throw new ArgumentNullException (nameof (registeredMethod));
			implementedMethod = implementedMethod ?? throw new ArgumentNullException (nameof (implementedMethod));
			registerAttribute = registerAttribute ?? throw new ArgumentNullException (nameof (registerAttribute));

			if (IsDynamicallyRegistered (topType, registeredMethod, implementedMethod, registerAttribute, out var marshalMethodEntry)) {
				return new DynamicallyRegisteredMarshalMethodEntry (topType, implementedMethod, registeredMethod, registerAttribute);
			}

			return marshalMethodEntry;
		}

		string GetAssemblyPathInfo (FieldDefinition? field)   => GetAssemblyPathInfo (field?.DeclaringType);
		string GetAssemblyPathInfo (MethodDefinition? method) => GetAssemblyPathInfo (method?.DeclaringType);
		string GetAssemblyPathInfo (TypeDefinition? type)     => GetAssemblyPathInfo (type?.Module?.Assembly);

		string GetAssemblyPathInfo (AssemblyDefinition? asmdef)
		{
			if (asmdef == null) {
				return "[assembly definition missing]";
			}

			string? path = asmdef.MainModule.FileName;
			if (String.IsNullOrEmpty (path)) {
				path = "unknown";
			}

			return $"[Arch: {targetArch}; Assembly: {path}]";
		}

		bool IsDynamicallyRegistered (TypeDefinition topType, MethodDefinition registeredMethod, MethodDefinition implementedMethod, CustomAttribute registerAttribute, [NotNullWhen (false)] out MarshalMethodEntry? marshalMethodEntry)
		{
			marshalMethodEntry = null;
			if (registerAttribute.ConstructorArguments.Count != 3) {
				log.LogWarning ($"Method '{registeredMethod.FullName}' will be registered dynamically, not enough arguments to the [Register] attribute to generate marshal method.");
				return true;
			}

			var connector = new ConnectorInfo ((string)registerAttribute.ConstructorArguments[2].Value);

			if (IsStandardHandler (topType, connector, registeredMethod, implementedMethod, jniName: (string)registerAttribute.ConstructorArguments[0].Value, jniSignature: (string)registerAttribute.ConstructorArguments[1].Value, out marshalMethodEntry)) {
				return false;
			}

			log.LogWarning ($"Method '{registeredMethod.FullName}' will be registered dynamically {GetAssemblyPathInfo (registeredMethod)}");
			return true;
		}

		bool IsStandardHandler (TypeDefinition topType, ConnectorInfo connector, MethodDefinition registeredMethod, MethodDefinition implementedMethod, string jniName, string jniSignature, [NotNullWhen (true)] out MarshalMethodEntry? marshalMethodEntry)
		{
			marshalMethodEntry = null;

			const string HandlerNameStart = "Get";
			const string HandlerNameEnd = "Handler";

			string connectorName = connector.MethodName;
			if (connectorName.Length < HandlerNameStart.Length + HandlerNameEnd.Length + 1 ||
			    !connectorName.StartsWith (HandlerNameStart, StringComparison.Ordinal) ||
			    !connectorName.EndsWith (HandlerNameEnd, StringComparison.Ordinal)) {
				log.LogWarning ($"Connector name '{connectorName}' must start with '{HandlerNameStart}', end with '{HandlerNameEnd}' and have at least one character between the two parts.");
				return false;
			}

			// TODO: if we can't find native callback and/or delegate field using `callbackNameCore`, fall back to `jniName` (which is the first argument to the `[Register]`
			// attribute). Or simply use `jniName` at once - needs testing.

			string callbackNameCore = connectorName.Substring (HandlerNameStart.Length, connectorName.Length - HandlerNameStart.Length - HandlerNameEnd.Length);
			string nativeCallbackName = $"n_{callbackNameCore}";
			string nativeConvertedCallbackName = $"n_{callbackNameCore}_mm_wrapper";
			string delegateFieldName = $"cb_{Char.ToLowerInvariant (callbackNameCore[0])}{callbackNameCore.Substring (1)}";

			TypeDefinition connectorDeclaringType = connector.AssemblyName == null ? registeredMethod.DeclaringType : FindType (resolver.Resolve (connector.AssemblyName), connector.TypeName);

			var ncbs = new NativeCallbackSignature (registeredMethod, log, tdCache);
			MethodDefinition nativeCallbackMethod = FindMethod (connectorDeclaringType, nativeCallbackName, ncbs);
			if (nativeCallbackMethod == null) {
				log.LogWarning ($"Unable to find native callback method '{nativeCallbackName}' in type '{connectorDeclaringType.FullName}', matching the '{registeredMethod.FullName}' signature (jniName: '{jniName}') {GetAssemblyPathInfo (connectorDeclaringType)}");
				return false;
			}

			if (!EnsureIsValidUnmanagedCallersOnlyTarget (nativeCallbackMethod, out bool needsBlittableWorkaround)) {
				return false;
			}

			MethodDefinition? nativeConvertedCallbackMethod = FindMethod (connectorDeclaringType, nativeConvertedCallbackName, ncbs);

			MethodDefinition connectorMethod = FindMethod (connectorDeclaringType, connectorName);

			// If the marshal method has already been converted, the connector method will have been removed
			if (connectorMethod == null && nativeConvertedCallbackMethod == null) {
				log.LogWarning ($"Connector method '{connectorName}' not found in type '{connectorDeclaringType.FullName}' {GetAssemblyPathInfo (connectorDeclaringType)}");
				return false;
			}

			if (connectorMethod != null && String.Compare ("System.Delegate", connectorMethod.ReturnType.FullName, StringComparison.Ordinal) != 0) {
				log.LogWarning ($"Connector '{connectorName}' in type '{connectorDeclaringType.FullName}' has invalid return type, expected 'System.Delegate', found '{connectorMethod.ReturnType.FullName}' {GetAssemblyPathInfo (connectorDeclaringType)}");
				return false;
			}

			// In the standard handler "pattern", the native callback backing field is private, static and thus in the same type
			// as the native callback.
			FieldDefinition delegateField = FindField (nativeCallbackMethod.DeclaringType, delegateFieldName);
			if (delegateField != null) {
				if (String.Compare ("System.Delegate", delegateField.FieldType.FullName, StringComparison.Ordinal) != 0) {
					log.LogWarning ($"delegate field '{delegateFieldName}' in type '{nativeCallbackMethod.DeclaringType.FullName}' has invalid type, expected 'System.Delegate', found '{delegateField.FieldType.FullName}' {GetAssemblyPathInfo (delegateField)}");
					return false;
				}
			}

			// TODO: check where DeclaringType is lost between here and rewriter, for:
			//
			// Classifying:
			//         method: Java.Lang.Object Microsoft.Maui.Controls.Platform.Compatibility.ShellSearchViewAdapter::GetItem(System.Int32)
			//         registered method: Java.Lang.Object Android.Widget.BaseAdapter::GetItem(System.Int32))
			//         Attr: Android.Runtime.RegisterAttribute (parameter count: 3)
			//         Top type: Microsoft.Maui.Controls.Platform.Compatibility.ShellSearchViewAdapter
			//         Managed type: Android.Widget.BaseAdapter, Mono.Android
			//         connector: GetGetItem_IHandler (from spec: 'GetGetItem_IHandler')
			//         connector name: GetGetItem_IHandler
			//         native callback name: n_GetItem_I
			//         delegate field name: cb_getItem_I
			// ##G1: Microsoft.Maui.Controls.Platform.Compatibility.ShellSearchViewAdapter -> crc640ec207abc449b2ca/ShellSearchViewAdapter
			// ##G1: top type: Microsoft.Maui.Controls.Platform.Compatibility.ShellSearchViewAdapter -> crc640ec207abc449b2ca/ShellSearchViewAdapter
			// ##G1: connectorMethod: System.Delegate Android.Widget.BaseAdapter::GetGetItem_IHandler()
			// ##G1: delegateField: System.Delegate Android.Widget.BaseAdapter::cb_getItem_I
			//
			// And in the rewriter:
			//
			//         System.IntPtr Android.Widget.BaseAdapter::n_GetItem_I(System.IntPtr,System.IntPtr,System.Int32) (token: 0x5fe3)
			// Top type == 'Microsoft.Maui.Controls.Platform.Compatibility.ShellSearchViewAdapter'
			// 	NativeCallback == 'System.IntPtr Android.Widget.BaseAdapter::n_GetItem_I(System.IntPtr,System.IntPtr,System.Int32)'
			// 	Connector == 'System.Delegate GetGetItem_IHandler()'
			// 	method.NativeCallback.CustomAttributes == Mono.Collections.Generic.Collection`1[Mono.Cecil.CustomAttribute]
			// 	method.Connector.DeclaringType == 'null'
			// 	method.Connector.DeclaringType.Methods == 'null'
			// 	method.CallbackField == System.Delegate cb_getItem_I
			// 	method.CallbackField?.DeclaringType == 'null'
			// 	method.CallbackField?.DeclaringType.Fields == 'null'

			if (nativeConvertedCallbackMethod is null) {
				marshalMethodEntry =
					new MarshalMethodEntry (
						topType,
						nativeCallbackMethod,
						connectorMethod,
						registeredMethod,
						implementedMethod,
						delegateField,
						JavaNativeTypeManager.ToJniName (topType, tdCache),
						jniName,
						jniSignature,
						needsBlittableWorkaround
					);
			} else {
				marshalMethodEntry =
					new ConvertedMarshalMethodEntry (
						topType,
						nativeCallbackMethod,
						connectorMethod,
						registeredMethod,
						implementedMethod,
						delegateField,
						JavaNativeTypeManager.ToJniName (topType, tdCache),
						jniName,
						jniSignature,
						needsBlittableWorkaround,
						nativeConvertedCallbackMethod
					);
			}

			return true;
		}

		bool EnsureIsValidUnmanagedCallersOnlyTarget (MethodDefinition method, out bool needsBlittableWorkaround)
		{
			needsBlittableWorkaround = false;

			// Requirements: https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedcallersonlyattribute?view=net-6.0#remarks
			if (!method.IsStatic) {
				return LogReasonWhyAndReturnFailure ($"is not static");
			}

			if (method.HasGenericParameters) {
				return LogReasonWhyAndReturnFailure ($"has generic parameters");
			}

			TypeReference type;
			if (String.Compare ("System.Void", method.ReturnType.FullName, StringComparison.Ordinal) != 0) {
				type = GetRealType (method.ReturnType);
				if (!IsAcceptable (type)) {
					needsBlittableWorkaround = true;
					WarnWhy ($"has a non-blittable return type '{type.FullName}'");
				}
			}

			if (method.DeclaringType.HasGenericParameters) {
				return LogReasonWhyAndReturnFailure ($"is declared in a type with generic parameters");
			}

			if (!method.HasParameters) {
				return true;
			}

			foreach (ParameterDefinition pdef in method.Parameters) {
				type = GetRealType (pdef.ParameterType);

				if (!IsAcceptable (type)) {
					needsBlittableWorkaround = true;
					WarnWhy ($"has a parameter ({pdef.Name}) of non-blittable type '{type.FullName}'");
				}
			}

			return true;

			bool IsAcceptable (TypeReference type)
			{
				if (type.IsArray) {
					var array = new ArrayType (type);
					if (array.Rank > 1) {
						return false;
					}
				}

				return type.IsBlittable ();
			}

			TypeReference GetRealType (TypeReference type)
			{
				if (type.IsArray) {
					return type.GetElementType ();
				}

				return type;
			}

			bool LogReasonWhyAndReturnFailure (string why)
			{
				log.LogWarning ($"Method '{method.FullName}' {why}. It cannot be used with the `[UnmanagedCallersOnly]` attribute");
				return false;
			}

			void WarnWhy (string why)
			{
				// TODO: change to LogWarning once the generator can output code which requires no non-blittable wrappers
				log.LogDebugMessage ($"Method '{method.FullName}' {why}. A workaround is required, this may make the application slower");
			}
		}

		TypeDefinition FindType (AssemblyDefinition asm, string typeName)
		{
			foreach (ModuleDefinition md in asm.Modules) {
				foreach (TypeDefinition td in md.Types) {
					TypeDefinition match = GetMatchingType (td);
					if (match != null) {
						return match;
					}
				}
			}

			return null;

			TypeDefinition GetMatchingType (TypeDefinition def)
			{
				if (String.Compare (def.FullName, typeName, StringComparison.Ordinal) == 0) {
					return def;
				}

				if (!def.HasNestedTypes) {
					return null;
				}

				TypeDefinition ret;
				foreach (TypeDefinition nested in def.NestedTypes) {
					ret = GetMatchingType (nested);
					if (ret != null) {
						return ret;
					}
				}

				return null;
			}
		}

		MethodDefinition FindMethod (TypeDefinition type, string methodName, IMethodSignatureMatcher signatureMatcher = null)
		{
			foreach (MethodDefinition method in type.Methods) {
				if (!method.IsManaged || method.IsConstructor) {
					continue;
				}

				if (String.Compare (methodName, method.Name, StringComparison.Ordinal) != 0) {
					continue;
				}

				if (signatureMatcher == null || signatureMatcher.Matches (method)) {
					return method;
				}
			}

			if (type.BaseType == null) {
				return null;
			}

			return FindMethod (tdCache.Resolve (type.BaseType), methodName, signatureMatcher);
		}

		FieldDefinition FindField (TypeDefinition type, string fieldName, bool lookForInherited = false)
		{
			foreach (FieldDefinition field in type.Fields) {
				if (String.Compare (field.Name, fieldName, StringComparison.Ordinal) == 0) {
					return field;
				}
			}

			if (!lookForInherited || type.BaseType == null) {
				return null;
			}

			return FindField (tdCache.Resolve (type.BaseType), fieldName, lookForInherited);
		}
	}
}
