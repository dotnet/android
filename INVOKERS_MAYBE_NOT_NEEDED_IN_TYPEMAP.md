# Invokers May Not Need TypeMap Entries

> Analysis of whether invoker types need their own entries in the type mapping system.

## Background

The current `type-mapping-api-v2-spec.md` includes invokers as first-class citizens in the typemap:
- Section 4.2: Interface-to-Invoker Mapping
- Section 6.4: Invoker Proxy generation
- `TryGetInvokerType(Type, out Type)` API

This document argues that **invokers don't need separate typemap entries or proxy classes**.

---

## Key Findings from Codebase Research

### 1. Invoker Classes are Generated by the Binding Generator

Invokers are generated by **the same binding generator** (`generator.dll` from `external/Java.Interop/tools/generator/`) in all scenarios:

- **Source:** `InterfaceInvokerClass.cs` generates invoker classes
- **MSBuild task:** `BindingsGenerator` in `Xamarin.Android.Bindings.Core.targets`
- **Trigger:** Runs when `@(_LibrariesToBind)` is non-empty
- **Output:** Pure C# classes compiled into the binding assembly

**Same generator code runs in all cases:**
- **SDK build** - generates Mono.Android.dll bindings for Android SDK
- **Binding library** - user creates bindings for 3rd party .jar/.aar
- **App with Java refs** - app references .jar/.aar with `Bind=true`

The only difference is what triggers it and which Java APIs are being bound.

```csharp
// From InterfaceInvokerClass.cs line 30
Attributes.Add (new RegisterAttr (iface.RawJniName, noAcw: true, ...));
```

The `noAcw: true` parameter sets `DoNotGenerateAcw=true` on the invoker.

### 2. Invokers Do NOT Generate .java Files

**Confirmed: No JCW/ACW is generated for invokers.**

From `RegisterAttr.cs` line 70:
```csharp
writer.WriteLine ($"[global::Java.Interop.JniTypeSignature (\"{Name}\", GenerateJavaPeer={(DoNotGenerateAcw ? "false" : "true")}{invokerType})]");
```

From `JavaTypeScanner.cs` lines 94-106:
```csharp
public static bool ShouldSkipJavaCallableWrapperGeneration (TypeDefinition type, IMetadataResolver resolver)
{
    // ...
    foreach (var c in CecilExtensions.GetTypeRegistrationAttributes (type)) {
        if (c.DoNotGenerateAcw) {
            return true;  // Skip JCW generation for types with DoNotGenerateAcw=true
        }
    }
    return false;
}
```

### 3. Invokers Do NOT Generate LLVM IR (.ll) Files

**Confirmed: No native stubs are generated for invokers.**

LLVM IR generation only happens for types with JCWs. Since invokers have `DoNotGenerateAcw=true`:
- No JCW → No LLVM IR stubs
- The `n_*` callback methods in invokers are for **dynamic registration** only

### 4. Interface Methods Do NOT Need .java or .ll Files

Interfaces themselves have `DoNotGenerateAcw=true`:
```csharp
// From Test.ME.ITestInterface.cs
[Register ("test/me/TestInterface", "", "Test.ME.ITestInterfaceInvoker")]
public partial interface ITestInterface : IJavaObject, IJavaPeerable { ... }
```

The third parameter of `[Register]` specifies the invoker type name for dynamic registration lookup.

### 5. Implementors ARE Different - They NEED JCWs

Implementors (e.g., `View.IOnClickListenerImplementor`) are the only interface-related types that need JCWs:

```csharp
// From Android.Views.View.cs line 99
[global::Android.Runtime.Register ("mono/android/view/View_OnClickListenerImplementor")]
internal sealed partial class IOnClickListenerImplementor : global::Java.Lang.Object, IOnClickListener { ... }
```

Notice: NO `DoNotGenerateAcw=true` - this type DOES get a JCW generated.

---

## The `n_*` Callbacks in Invokers

Invokers contain static `n_*` callback methods (e.g., `n_OnClick_Landroid_view_View_`). These are used for:

1. **Dynamic registration (legacy):** The `GetOnClick_Landroid_view_View_Handler()` method returns a delegate pointing to `n_OnClick_...`
2. **Called by Implementor UCO wrappers:** When an Implementor's JCW native method is invoked via LLVM IR, the UCO wrapper calls the invoker's `n_*` method

**Critical insight:** These `n_*` methods are NOT native entry points for the invoker itself. They're helper methods that contain the actual callback logic.

**Backwards compatibility constraint:** The `n_*` methods are already "baked into" existing customer binding libraries. While Mono.Android.dll is rebuilt in sync with the typemap code generator (so we could change it), third-party binding libraries that customers have built contain these `n_*` methods. We don't want to force customers to rebuild their libraries, so implementor UCO wrappers must call the existing `n_*` methods to maintain compatibility.

---

## How Invokers Work Today (Runtime)

When `CreatePeer` encounters an interface/abstract type:

```csharp
// JniRuntime.JniValueManager.cs:403
type = Runtime.TypeManager.GetInvokerType(type) ?? type;
var self = GetUninitializedObject(type);
```

The invoker type replaces the interface type and is instantiated via activation constructor.

### Invoker Discovery

Currently uses `[JniTypeSignature(InvokerType=typeof(...))]` attribute:

```csharp
[JniTypeSignature("net/dot/jni/test/JavaInterface", InvokerType=typeof(IJavaInterfaceInvoker))]
interface IJavaInterface : IJavaPeerable { ... }
```

The `GetInvokerTypeCore` method reads this attribute to find the invoker.

---

## Key Insight: Interface Proxy Can Handle Everything

The spec recommends (Section 6.3) that interface proxies directly create invoker instances:

```csharp
public sealed class IOnClickListener_Proxy : JavaPeerProxy
{
    public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
        => new IOnClickListenerInvoker(handle, transfer);  // Directly creates invoker!
}
```

If the interface's `CreateInstance` directly instantiates the invoker, then:

1. **No typemap lookup needed** for the invoker type
2. **No proxy class needed** for the invoker
3. **`TryGetInvokerType` becomes mostly obsolete**

| Invoker Characteristic | Implication |
|------------------------|-------------|
| No JCW (`DoNotGenerateAcw=true`) | No LLVM IR stubs → No `GetFunctionPointer` needed |
| No Java-initiated instantiation | Never activated via `nc_activate_*` from Java |
| Only created when wrapping Java objects | Interface proxy's `CreateInstance` handles this |
| No user subclasses expected | Not a "CreateInstance" scenario users would trigger |
| Shares Java type name with interface | Would be duplicate entry in `_externalTypeMap` anyway |

### What Would an Invoker Proxy Even Do?

```csharp
// Hypothetical invoker proxy - but why generate this?
public sealed class IOnClickListenerInvoker_Proxy : JavaPeerProxy
{
    public override IntPtr GetFunctionPointer(int methodIndex)
        => throw new NotSupportedException("Invokers have no JCW");
    
    public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
        => new IOnClickListenerInvoker(handle, transfer);
}
```

This is **identical** to what the interface proxy already does! The invoker proxy is redundant.

---

## Revised Type Categorization

| Type | Needs TypeMap Entry? | Needs Proxy Class? | Why |
|------|---------------------|-------------------|-----|
| **Interface** | ✅ Yes | ✅ Yes | Java name lookup; `CreateInstance` → invoker |
| **Invoker** | ❌ No | ❌ No | Created by interface proxy directly |
| **Implementor** | ✅ Yes | ✅ Yes | Has JCW; needs activation + callbacks |
| **Abstract class** | ✅ Yes | ✅ Yes | Has invoker pattern like interfaces |
| **Concrete MCW** | ✅ Yes | ✅ Yes | Instance creation |
| **User JCW class** | ✅ Yes | ✅ Yes | Activation + virtual callbacks |

---

## Trimming Consideration

The invoker type **automatically survives trimming** through the direct instantiation in the interface proxy:

```csharp
public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
    => new IOnClickListenerInvoker(handle, transfer);  // Hard reference!
```

The trimmer follows this `new` expression and preserves `IOnClickListenerInvoker`. No `TypeMapAssociation` attribute is needed.

**This is simpler than the original spec** - no association attributes, no proxy classes, just the direct instantiation.

---

## `TryGetInvokerType` API

### Current Usages

1. **`CreatePeer` fallback** - but interface proxy handles this directly
2. **Reflection scenarios** - rare, could use attribute directly
3. **Legacy code** - transitional support

### Recommendation

Keep the API but document it as **legacy/fallback**:

```csharp
/// <summary>
/// Gets the invoker type for an interface or abstract class.
/// </summary>
/// <remarks>
/// In the TypeMap v2 system, this is primarily used as a fallback.
/// The preferred path is for interface proxies to directly instantiate
/// invokers in their CreateInstance method.
/// </remarks>
bool TryGetInvokerType(Type type, [NotNullWhen(true)] out Type? invokerType);
```

---

## Spec Changes Required

### Remove/Simplify

1. **Section 6.4** (Invoker Proxy) - remove entirely
2. **Section 16.2** - remove "Generate proxy types for Invokers" item
3. **Table in Section 4.2.1** - update to show invokers don't need proxies

### Keep

1. **`TryGetInvokerType` in `ITypeMap`** - as legacy/fallback API (reads `[JniTypeSignature]` attribute)

### Update

1. **Section 5** - Clarify that invokers are not in the proxy type table
2. **Section 9.2** - Mark `TryGetInvokerType` as fallback

---

## Test Cases to Verify

From `external/Java.Interop/tests/Java.Interop-Tests/`:

1. **`JniRuntime.JniTypeManagerTests.cs:15-27`** - `GetInvokerType()` test
2. **`JniRuntimeJniValueManagerContract.cs:148-161`** - `CreatePeer_UsesFallbackType` test

These tests should continue to pass because:
- `GetInvokerType` still works (reads `[JniTypeSignature]` attribute)
- The test creates a peer for `IJavaInterface` and expects `IJavaInterfaceInvoker`

With the new approach, the interface proxy's `CreateInstance` would handle this directly, but the test doesn't care *how* the invoker is created, just that the result is an invoker instance.

---

## Summary

**Invokers don't need:**
- ❌ Their own entries in `_externalTypeMap`
- ❌ Their own proxy classes
- ❌ `GetFunctionPointer` implementations (no JCW)
- ❌ `TypeMapAssociation` attributes (direct `new` in interface proxy handles trimming)
- ❌ "Activation constructor" pattern (not instantiated via reflection)

**Invokers still need:**
- ✅ A public constructor matching what the interface proxy calls: `(IntPtr, JniHandleOwnership)`

**This simplifies codegen** by eliminating an entire category of proxy types.

---

## Confirmation of Assumptions

### ✅ Invoker classes are generated by the binding generator
- Same `generator.dll` runs in all scenarios (SDK build, binding library, app with Java refs)
- Triggered by the `BindingsGenerator` MSBuild task when `@(_LibrariesToBind)` is non-empty
- Output as C# classes compiled into the binding assembly
- Key point: generated by the **binding generator pipeline**, not by JCW/LLVM IR generation pipeline

### ✅ Invokers never need .java files generated
- `DoNotGenerateAcw=true` / `GenerateJavaPeer=false` is always set
- `JavaTypeScanner.ShouldSkipJavaCallableWrapperGeneration()` returns `true` for invokers
- No Java source or bytecode is ever generated

### ✅ Invokers never need .ll (LLVM IR) files generated
- LLVM IR stubs are only generated for types with JCWs
- Since invokers have no JCW, they have no LLVM IR
- The `n_*` callbacks in invokers are static C# methods used for dynamic registration, not native entry points

### ✅ Interface methods don't need .java or .ll for their invokers
- Interfaces also have `DoNotGenerateAcw=true`
- The only interface-related type that needs a JCW is the **Implementor**
- Implementors have a different Java name (e.g., `mono/android/view/View_OnClickListenerImplementor`) and DO get JCWs

### Summary Table

| Type | .java generated? | .ll generated? | Generated by? |
|------|-----------------|----------------|---------------|
| Interface (e.g., `IOnClickListener`) | ❌ No | ❌ No | Binding generator |
| Invoker (e.g., `IOnClickListenerInvoker`) | ❌ No | ❌ No | Binding generator |
| Implementor (e.g., `IOnClickListenerImplementor`) | ✅ Yes | ✅ Yes (if marshal methods) | Binding generator (C#) + JCW pipeline (.java/.ll) |
| User class extending Java class | ✅ Yes | ✅ Yes (if marshal methods) | JCW pipeline |

**Two distinct pipelines:**
1. **Binding generator** (`generator.dll`) - produces C# bindings (interfaces, invokers, implementors, MCWs)
2. **JCW pipeline** (`GenerateJavaStubs`, `GenerateNativeMarshalMethodSources`) - produces .java + .ll for types that need Java-callable wrappers

Invokers only go through pipeline 1. They never enter pipeline 2 because they have `DoNotGenerateAcw=true`.

---

## ✅ VERIFIED: Invokers Successfully Removed from TypeMap (2025-01-25)

The change was implemented and verified working:

### Implementation

Added `IsInvokerType()` helper to identify invokers:
```csharp
bool IsInvokerType (JavaPeerInfo peer)
{
    // Invokers always have DoNotGenerateAcw=true (they wrap existing Java objects)
    if (!peer.DoNotGenerateAcw)
        return false;
    
    // Check if the managed type name ends with "Invoker"
    return peer.ManagedTypeName.EndsWith ("Invoker", StringComparison.Ordinal);
}
```

Invokers are filtered out before proxy generation:
```csharp
var filteredPeers = javaPeers.Where (p => !IsInvokerType (p)).ToList ();
```

### Results

**Dramatic reduction in TypeMap entries and aliases:**

| Metric | Before | After | Reduction |
|--------|--------|-------|-----------|
| Proxies generated | 8,811 | 7,067 | 1,744 (20%) |
| Invokers skipped | 0 | 1,744 | — |
| Type map entries | 10,541 | 7,095 | 3,446 (33%) |
| **Aliases** | **3,506** | **60** | **98%** |

### Verification

The HelloWorld sample app works correctly after this change:
- `MainActivity` onCreate/onResume callbacks work
- `MyClickListener` onClick callbacks work
- Button clicks increment the counter as expected

### Why This Works

1. **Invokers share JNI names with interfaces** - e.g., both `IErrorHandler` and `IErrorHandlerInvoker` map to `org/xml/sax/ErrorHandler`. This was creating thousands of unnecessary aliases.

2. **Invokers are never looked up via TypeMap** - When Java returns an interface type, the interface proxy's `CreateInstance` directly instantiates the invoker:
   ```csharp
   public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
       => new IErrorHandlerInvoker(handle, transfer);
   ```

3. **Invokers have no JCW** - With `DoNotGenerateAcw=true`, there's no Java class, no LLVM IR stub, no `GetFunctionPointer` calls. The proxy would be empty.

### Conclusion

**Invokers should NOT be in the TypeMap.** This simplification:
- Reduces TypeMap size by 20%
- Eliminates 98% of aliases
- Reduces generated proxy count
- Has no runtime impact (all tests pass)
