# Invokers May Not Need TypeMap Entries

> Analysis of whether invoker types need their own entries in the type mapping system.

## Background

The current `type-mapping-api-v2-spec.md` includes invokers as first-class citizens in the typemap:
- Section 4.2: Interface-to-Invoker Mapping
- Section 6.4: Invoker Proxy generation
- `TryGetInvokerType(Type, out Type)` API

This document argues that **invokers don't need separate typemap entries or proxy classes**.

---

## Key Findings from Codebase Research

### 1. Invoker Classes are Generated at SDK/Binding Build Time

Invokers are generated by the binding generator (`external/Java.Interop/tools/generator/`):

- **Source:** `InterfaceInvokerClass.cs` generates invoker classes
- **Timing:** SDK build time (when Mono.Android.dll is built), NOT app build time
- **Output:** Pure C# classes in the binding assembly

```csharp
// From InterfaceInvokerClass.cs line 30
Attributes.Add (new RegisterAttr (iface.RawJniName, noAcw: true, ...));
```

The `noAcw: true` parameter sets `DoNotGenerateAcw=true` on the invoker.

### 2. Invokers Do NOT Generate .java Files

**Confirmed: No JCW/ACW is generated for invokers.**

From `RegisterAttr.cs` line 70:
```csharp
writer.WriteLine ($"[global::Java.Interop.JniTypeSignature (\"{Name}\", GenerateJavaPeer={(DoNotGenerateAcw ? "false" : "true")}{invokerType})]");
```

From `JavaTypeScanner.cs` lines 94-106:
```csharp
public static bool ShouldSkipJavaCallableWrapperGeneration (TypeDefinition type, IMetadataResolver resolver)
{
    // ...
    foreach (var c in CecilExtensions.GetTypeRegistrationAttributes (type)) {
        if (c.DoNotGenerateAcw) {
            return true;  // Skip JCW generation for types with DoNotGenerateAcw=true
        }
    }
    return false;
}
```

### 3. Invokers Do NOT Generate LLVM IR (.ll) Files

**Confirmed: No native stubs are generated for invokers.**

LLVM IR generation only happens for types with JCWs. Since invokers have `DoNotGenerateAcw=true`:
- No JCW → No LLVM IR stubs
- The `n_*` callback methods in invokers are for **dynamic registration** only

### 4. Interface Methods Do NOT Need .java or .ll Files

Interfaces themselves have `DoNotGenerateAcw=true`:
```csharp
// From Test.ME.ITestInterface.cs
[Register ("test/me/TestInterface", "", "Test.ME.ITestInterfaceInvoker")]
public partial interface ITestInterface : IJavaObject, IJavaPeerable { ... }
```

The third parameter of `[Register]` specifies the invoker type name for dynamic registration lookup.

### 5. Implementors ARE Different - They NEED JCWs

Implementors (e.g., `View.IOnClickListenerImplementor`) are the only interface-related types that need JCWs:

```csharp
// From Android.Views.View.cs line 99
[global::Android.Runtime.Register ("mono/android/view/View_OnClickListenerImplementor")]
internal sealed partial class IOnClickListenerImplementor : global::Java.Lang.Object, IOnClickListener { ... }
```

Notice: NO `DoNotGenerateAcw=true` - this type DOES get a JCW generated.

---

## The `n_*` Callbacks in Invokers

Invokers contain static `n_*` callback methods (e.g., `n_OnClick_Landroid_view_View_`). These are used for:

1. **Dynamic registration:** The `GetOnClick_Landroid_view_View_Handler()` method returns a delegate pointing to `n_OnClick_...`
2. **Called by Implementors:** When an Implementor's JCW native method is invoked, it goes through the callback

**Critical insight:** These `n_*` methods are NOT called from LLVM IR stubs for the invoker itself. They're helper methods used by:
- Dynamic JNI registration (legacy path)
- Implementor proxies (in the new typemap v2 system)

---

## How Invokers Work Today (Runtime)

When `CreatePeer` encounters an interface/abstract type:

```csharp
// JniRuntime.JniValueManager.cs:403
type = Runtime.TypeManager.GetInvokerType(type) ?? type;
var self = GetUninitializedObject(type);
```

The invoker type replaces the interface type and is instantiated via activation constructor.

### Invoker Discovery

Currently uses `[JniTypeSignature(InvokerType=typeof(...))]` attribute:

```csharp
[JniTypeSignature("net/dot/jni/test/JavaInterface", InvokerType=typeof(IJavaInterfaceInvoker))]
interface IJavaInterface : IJavaPeerable { ... }
```

The `GetInvokerTypeCore` method reads this attribute to find the invoker.

---

## Key Insight: Interface Proxy Can Handle Everything

The spec recommends (Section 6.3) that interface proxies directly create invoker instances:

```csharp
public sealed class IOnClickListener_Proxy : JavaPeerProxy
{
    public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
        => new IOnClickListenerInvoker(handle, transfer);  // Directly creates invoker!
}
```

If the interface's `CreateInstance` directly instantiates the invoker, then:

1. **No typemap lookup needed** for the invoker type
2. **No proxy class needed** for the invoker
3. **`TryGetInvokerType` becomes mostly obsolete**

| Invoker Characteristic | Implication |
|------------------------|-------------|
| No JCW (`DoNotGenerateAcw=true`) | No LLVM IR stubs → No `GetFunctionPointer` needed |
| No Java-initiated instantiation | Never activated via `nc_activate_*` from Java |
| Only created when wrapping Java objects | Interface proxy's `CreateInstance` handles this |
| No user subclasses expected | Not a "CreateInstance" scenario users would trigger |
| Shares Java type name with interface | Would be duplicate entry in `_externalTypeMap` anyway |

### What Would an Invoker Proxy Even Do?

```csharp
// Hypothetical invoker proxy - but why generate this?
public sealed class IOnClickListenerInvoker_Proxy : JavaPeerProxy
{
    public override IntPtr GetFunctionPointer(int methodIndex)
        => throw new NotSupportedException("Invokers have no JCW");
    
    public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
        => new IOnClickListenerInvoker(handle, transfer);
}
```

This is **identical** to what the interface proxy already does! The invoker proxy is redundant.

---

## Revised Type Categorization

| Type | Needs TypeMap Entry? | Needs Proxy Class? | Why |
|------|---------------------|-------------------|-----|
| **Interface** | ✅ Yes | ✅ Yes | Java name lookup; `CreateInstance` → invoker |
| **Invoker** | ❌ No | ❌ No | Created by interface proxy directly |
| **Implementor** | ✅ Yes | ✅ Yes | Has JCW; needs activation + callbacks |
| **Abstract class** | ✅ Yes | ✅ Yes | Has invoker pattern like interfaces |
| **Concrete MCW** | ✅ Yes | ✅ Yes | Instance creation |
| **User JCW class** | ✅ Yes | ✅ Yes | Activation + virtual callbacks |

---

## Trimming Consideration

The invoker type **automatically survives trimming** through the direct instantiation in the interface proxy:

```csharp
public override IJavaPeerable CreateInstance(IntPtr handle, JniHandleOwnership transfer)
    => new IOnClickListenerInvoker(handle, transfer);  // Hard reference!
```

The trimmer follows this `new` expression and preserves `IOnClickListenerInvoker`. No `TypeMapAssociation` attribute is needed.

**This is simpler than the original spec** - no association attributes, no proxy classes, just the direct instantiation.

---

## `TryGetInvokerType` API

### Current Usages

1. **`CreatePeer` fallback** - but interface proxy handles this directly
2. **Reflection scenarios** - rare, could use attribute directly
3. **Legacy code** - transitional support

### Recommendation

Keep the API but document it as **legacy/fallback**:

```csharp
/// <summary>
/// Gets the invoker type for an interface or abstract class.
/// </summary>
/// <remarks>
/// In the TypeMap v2 system, this is primarily used as a fallback.
/// The preferred path is for interface proxies to directly instantiate
/// invokers in their CreateInstance method.
/// </remarks>
bool TryGetInvokerType(Type type, [NotNullWhen(true)] out Type? invokerType);
```

---

## Spec Changes Required

### Remove/Simplify

1. **Section 6.4** (Invoker Proxy) - remove entirely
2. **Section 16.2** - remove "Generate proxy types for Invokers" item
3. **Table in Section 4.2.1** - update to show invokers don't need proxies

### Keep

1. **`TryGetInvokerType` in `ITypeMap`** - as legacy/fallback API (reads `[JniTypeSignature]` attribute)

### Update

1. **Section 5** - Clarify that invokers are not in the proxy type table
2. **Section 9.2** - Mark `TryGetInvokerType` as fallback

---

## Test Cases to Verify

From `external/Java.Interop/tests/Java.Interop-Tests/`:

1. **`JniRuntime.JniTypeManagerTests.cs:15-27`** - `GetInvokerType()` test
2. **`JniRuntimeJniValueManagerContract.cs:148-161`** - `CreatePeer_UsesFallbackType` test

These tests should continue to pass because:
- `GetInvokerType` still works (reads `[JniTypeSignature]` attribute)
- The test creates a peer for `IJavaInterface` and expects `IJavaInterfaceInvoker`

With the new approach, the interface proxy's `CreateInstance` would handle this directly, but the test doesn't care *how* the invoker is created, just that the result is an invoker instance.

---

## Summary

**Invokers don't need:**
- ❌ Their own entries in `_externalTypeMap`
- ❌ Their own proxy classes
- ❌ `GetFunctionPointer` implementations (no JCW)
- ❌ `TypeMapAssociation` attributes (direct `new` in interface proxy handles trimming)
- ❌ "Activation constructor" pattern (not instantiated via reflection)

**Invokers still need:**
- ✅ A public constructor matching what the interface proxy calls: `(IntPtr, JniHandleOwnership)`

**This simplifies codegen** by eliminating an entire category of proxy types.

---

## Confirmation of Assumptions

### ✅ Invoker classes are generated at SDK/binding build time
- Generated by `InterfaceInvokerClass.cs` in the binding generator
- Output as C# classes in the binding assembly (e.g., Mono.Android.dll)
- NOT generated at app build time

### ✅ Invokers never need .java files generated
- `DoNotGenerateAcw=true` / `GenerateJavaPeer=false` is always set
- `JavaTypeScanner.ShouldSkipJavaCallableWrapperGeneration()` returns `true` for invokers
- No Java source or bytecode is ever generated

### ✅ Invokers never need .ll (LLVM IR) files generated
- LLVM IR stubs are only generated for types with JCWs
- Since invokers have no JCW, they have no LLVM IR
- The `n_*` callbacks in invokers are static C# methods used for dynamic registration, not native entry points

### ✅ Interface methods don't need .java or .ll for their invokers
- Interfaces also have `DoNotGenerateAcw=true`
- The only interface-related type that needs a JCW is the **Implementor**
- Implementors have a different Java name (e.g., `mono/android/view/View_OnClickListenerImplementor`) and DO get JCWs

### Summary Table

| Type | .java generated? | .ll generated? | Generated when? |
|------|-----------------|----------------|-----------------|
| Interface (e.g., `IOnClickListener`) | ❌ No | ❌ No | SDK build |
| Invoker (e.g., `IOnClickListenerInvoker`) | ❌ No | ❌ No | SDK build |
| Implementor (e.g., `IOnClickListenerImplementor`) | ✅ Yes | ✅ Yes (if marshal methods) | App build |
| User class extending Java class | ✅ Yes | ✅ Yes (if marshal methods) | App build |
